<!doctype html>
<head>
  <meta charset="utf-8">
  <title>Project: A Programming Language :: Eloquent JavaScript</title>
  <link rel=stylesheet href="../node_modules/codemirror/lib/codemirror.css">
  <script src="../node_modules/codemirror/lib/codemirror.js"></script>
  <script src="../node_modules/codemirror/mode/javascript/javascript.js"></script>
  <script src="../node_modules/codemirror/mode/css/css.js"></script>
  <script src="../node_modules/codemirror/mode/xml/xml.js"></script>
  <script src="../node_modules/codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <script src="../node_modules/codemirror/addon/edit/matchbrackets.js"></script>
  <script src="../node_modules/acorn/acorn.js"></script>
  <script src="../node_modules/acorn/util/walk.js"></script>
  <link rel=stylesheet href="ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 11;var sandboxLoadFiles = ["js/11_language.js"];</script>
</head>

<article>
<nav>
  <a href="10_modules.html" title="previous chapter">⬅</a>
  <a href="index.html" title="cover">⬆</a>
  <a href="12_browser.html" title="next chapter">➡</a>
</nav>

<h1><div class=chap_num>Chapter 11</div>Project: A Programming Language</h1>
<blockquote>
<p><a class=p_ident id="p_Mt+zDiEThG" href="#p_Mt+zDiEThG"></a>The evaluator, which determines the meaning of expressions in a
programming language, is just another program.</p>
 <footer>Hal Abelson and Gerald Sussman, <cite>Structure and Interpretation of Computer Programs</cite></footer>
</blockquote>
<blockquote>
<p><a class=p_ident id="p_KjZntSSadH" href="#p_KjZntSSadH"></a>When a student asked the master about the nature of the cycle of Data
and Control, Yuan-Ma replied ‘Think of a compiler, compiling itself.’</p>
 <footer>Master Yuan-Ma, <cite>The Book of Programming</cite></footer>
</blockquote>
<p><a class=p_ident id="p_sLOpE8A1YZ" href="#p_sLOpE8A1YZ"></a>Building your own programming language, though not necessary a very
useful pursuit, is surprisingly easy—as long as you do not take it
too seriously—and very enlightening.</p>
<p><a class=p_ident id="p_XWyxXihLGw" href="#p_XWyxXihLGw"></a>The main thing I want to show in this chapter is that there is no
magic involved. I&#8217;ve often felt that some human invention was so
immensely clever and complicated that I&#8217;d never be able to understand
it. But with a little reading and tinkering, such things, again and
again, show themselves to be quite mundane.</p>
<h2 id="_parsing">Parsing</h2>
<p><a class=p_ident id="p_9wnN5K+uPL" href="#p_9wnN5K+uPL"></a>The most immediately visible part of a programming language is its
syntax—its notation. A parser is a program that reads a piece of text,
and produces a data structure that explicitly shows the structure
of the program contained in the text. If the text does not form a
valid program, the parser should complain about that.</p>
<p><a class=p_ident id="p_/qJ2+kk2My" href="#p_/qJ2+kk2My"></a>Our language will have a very simple and uniform syntax. Everything in
the language will be an expression. An expression can be a variable, a
number, a string, or an application. Applications are used for
function calls, but also for constructs like <code>if</code> or <code>while</code>.</p>
<p><a class=p_ident id="p_mADcIuR3Iz" href="#p_mADcIuR3Iz"></a>To keep the parser simple, strings in this language do not support
anything like backslash escapes, they are simply a sequence of
characters that are not double quotes, wrapped in double quotes.
Numbers are a sequence of digits. And variable names can consist of
any character that is not whitespace and does not have a special
meaning in the language.</p>
<p><a class=p_ident id="p_e1Ljpri4pl" href="#p_e1Ljpri4pl"></a>Applications are written the way they are in JavaScript, by putting
parentheses after an expression, and having any number of arguments,
separated by commas, between those parentheses.</p>
<pre>do(define(x, 10),
   if(&gt;(x, 5)),
      print("large"),
      print("small"))</pre>
<p><a class=p_ident id="p_Y6Tl80peLB" href="#p_Y6Tl80peLB"></a>The uniformity of the language means that what would be an operator in
JavaScript (such as “&gt;”) is a normal variable, applied just like other
functions, in this language. Since there is also no concept of a
block, doing multiple things in sequence is written as an application
of the <code>do</code> construct.</p>
<p><a class=p_ident id="p_SvAqy0sfaC" href="#p_SvAqy0sfaC"></a>The data structure the parser will use to describe such a program
consists of objects, each of which has a <code>type</code> property indicating
the kind of expression it is (<code>"word"</code>, <code>"value"</code>, or <code>"apply"</code>), and
other properties to describe its content. The <code>&gt;(x, 5)</code> part of the
program above would be represented like this:</p>
<pre>{
  type: "apply",
  operator: {type: "word", name: "&gt;"},
  args: [
    {type: "word", name: "x"},
    {type: "value", value: 5}
  ]
}</pre>
<p><a class=p_ident id="p_wZheW4Mu+K" href="#p_wZheW4Mu+K"></a>Such a data structure is called a <em>syntax tree</em>. When viewing the
objects as points, and the links between them as lines between those
points, it has a tree-like shape. The fact that expressions contain
other expressions, which in turn might contain more expression, is
similar to the way branches split and split again.</p>
<p><a class=p_ident id="p_ihyCJZrzQj" href="#p_ihyCJZrzQj"></a>The parser we wrote for the configuration file format in Chapter 9 had
a very simple structure—it split the input into lines, and handled one
line at a time, where each line had one of a few simple forms.</p>
<p><a class=p_ident id="p_OzDGCmv7Gf" href="#p_OzDGCmv7Gf"></a>This time, we must find a different approach. Expressions are not
separated by lines, and they have a recursive structure. Application
expressions themselves contain other expressions.</p>
<p><a class=p_ident id="p_doWGMjYGVI" href="#p_doWGMjYGVI"></a>Fortunately, this problem can be solved elegantly by using a parsing
function that is recursive in a way that reflects the recursive nature
of the language.</p>
<p><a class=p_ident id="p_vEMw7RQ1iA" href="#p_vEMw7RQ1iA"></a>We define a function <code>parseExpression</code>, which takes a string as input,
and returns an object that contains the data structure for the
expression at the start of this string, along with the part of the
string left after parsing this expression. When parsing
sub-expressions (the argument to an application, for example), this
function can be called again, yielding the argument expression as well
as the text that remains (which may contain more arguments, or the
closing parentheses that ends the list of arguments).</p>
<p><a class=p_ident id="p_qQZOLuZdMw" href="#p_qQZOLuZdMw"></a>This is the first part of the parser:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_X80Bp8oPT8" href="#c_X80Bp8oPT8"></a><span class="cm-keyword">function</span> <span class="cm-variable">parseExpression</span>(<span class="cm-def">program</span>) {
  <span class="cm-variable-2">program</span> <span class="cm-operator">=</span> <span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">program</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">match</span>, <span class="cm-def">expr</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^"([^"]*)"/</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">program</span>))
    <span class="cm-variable-2">expr</span> <span class="cm-operator">=</span> {<span class="cm-property">type</span>: <span class="cm-string">"value"</span>, <span class="cm-property">value</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">1</span>]};
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^\d+\b/</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">program</span>))
    <span class="cm-variable-2">expr</span> <span class="cm-operator">=</span> {<span class="cm-property">type</span>: <span class="cm-string">"value"</span>, <span class="cm-property">value</span>: <span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">0</span>])};
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^[^\s(),"]+/</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">program</span>))
    <span class="cm-variable-2">expr</span> <span class="cm-operator">=</span> {<span class="cm-property">type</span>: <span class="cm-string">"word"</span>, <span class="cm-property">name</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">0</span>]};
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Unexpected syntax: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">program</span>);

  <span class="cm-keyword">return</span> <span class="cm-variable">parseApply</span>(<span class="cm-variable-2">expr</span>, <span class="cm-variable-2">program</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">0</span>].<span class="cm-property">length</span>));
}

<span class="cm-keyword">function</span> <span class="cm-variable">skipSpace</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">first</span> <span class="cm-operator">=</span> <span class="cm-variable-2">string</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">first</span> <span class="cm-operator">==</span> <span class="cm-operator">-</span><span class="cm-number">1</span>) <span class="cm-keyword">return</span> <span class="cm-string">""</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">string</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">first</span>);
}</pre>
<p><a class=p_ident id="p_rjSzSpHhfd" href="#p_rjSzSpHhfd"></a>Because the language allows any amount of whitespace between its
elements, we have to repeatedly cut the whitespace off the start of
the program string. This is what the <code>skipSpace</code> function helps with.</p>
<p><a class=p_ident id="p_FglUPeozx+" href="#p_FglUPeozx+"></a>After skipping any leading space, <code>parseExpression</code> uses three regular
expressions to spot the three simple (atomic) elements that the
language supports—strings, numbers, and words. Depending on which one
matches, it constructs a different kind of data structure. If none
matches, the input is not a valid expression, and it throws an error.
<code>SyntaxError</code> is a standard error object type, which is also used when
an attempt is made to run an invalid JavaScript program.</p>
<p><a class=p_ident id="p_SHT28zA+Zh" href="#p_SHT28zA+Zh"></a>We can then cut off the part that we matched from the program string
(skipping whitespace again), and pass that, along with the object for
the expression, to <code>parseApply</code>, which checks whether this is an
application, and if so, handles the parsing of a parenthesized list of
arguments.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_1pgBEN5cCa" href="#c_1pgBEN5cCa"></a><span class="cm-keyword">function</span> <span class="cm-variable">parseApply</span>(<span class="cm-def">left</span>, <span class="cm-def">program</span>) {
  <span class="cm-variable-2">program</span> <span class="cm-operator">=</span> <span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">program</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">program</span>[<span class="cm-number">0</span>] <span class="cm-operator">!=</span> <span class="cm-string">"("</span>)
    <span class="cm-keyword">return</span> {<span class="cm-property">expr</span>: <span class="cm-variable-2">left</span>, <span class="cm-property">rest</span>: <span class="cm-variable-2">program</span>};

  <span class="cm-variable-2">program</span> <span class="cm-operator">=</span> <span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">program</span>.<span class="cm-property">slice</span>(<span class="cm-number">1</span>));
  <span class="cm-keyword">var</span> <span class="cm-def">expr</span> <span class="cm-operator">=</span> {<span class="cm-property">type</span>: <span class="cm-string">"apply"</span>, <span class="cm-property">operator</span>: <span class="cm-variable-2">left</span>, <span class="cm-property">args</span>: []};
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">program</span>[<span class="cm-number">0</span>] <span class="cm-operator">!=</span> <span class="cm-string">")"</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">arg</span> <span class="cm-operator">=</span> <span class="cm-variable">parseExpression</span>(<span class="cm-variable-2">program</span>);
    <span class="cm-variable-2">expr</span>.<span class="cm-property">args</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">arg</span>.<span class="cm-property">expr</span>);
    <span class="cm-variable-2">program</span> <span class="cm-operator">=</span> <span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">arg</span>.<span class="cm-property">rest</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">program</span>[<span class="cm-number">0</span>] <span class="cm-operator">==</span> <span class="cm-string">","</span>)
      <span class="cm-variable-2">program</span> <span class="cm-operator">=</span> <span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">program</span>.<span class="cm-property">slice</span>(<span class="cm-number">1</span>));
    <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">program</span>[<span class="cm-number">0</span>] <span class="cm-operator">!=</span> <span class="cm-string">")"</span>)
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Expected ',' or ')'"</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable">parseApply</span>(<span class="cm-variable-2">expr</span>, <span class="cm-variable-2">program</span>.<span class="cm-property">slice</span>(<span class="cm-number">1</span>));
}</pre>
<p><a class=p_ident id="p_I71H7ro2MW" href="#p_I71H7ro2MW"></a>If the next character in the program is not an opening parenthesis,
this is not an application, and <code>parseApply</code> simply returns the
expression it was given.</p>
<p><a class=p_ident id="p_rdoND4Um+i" href="#p_rdoND4Um+i"></a>Otherwise, it skips the opening parenthesis, and creates the syntax
node for this application expression. It then recusively calls
<code>parseExpression</code> to parse each argument until a closing parenthesis
is found. The recursion is indirect, through <code>parseApply</code> and
<code>parseExpression</code> calling each other.</p>
<p><a class=p_ident id="p_tYbJcSDZTH" href="#p_tYbJcSDZTH"></a>Finally, <code>parseApply</code> is called again, to see if this application is
followed by another set of parentheses (such as <code>multiplier(2)(1)</code>).</p>
<p><a class=p_ident id="p_raL98ujvee" href="#p_raL98ujvee"></a>This is almost all we need to parse our language. We wrap it in a
convenient <code>parse</code> function that verifies that no text remains after
the program, and gives us the program&#8217;s data structure.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_j7Ip+SRvOX" href="#c_j7Ip+SRvOX"></a><span class="cm-keyword">function</span> <span class="cm-variable">parse</span>(<span class="cm-def">program</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">parseExpression</span>(<span class="cm-variable-2">program</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">result</span>.<span class="cm-property">rest</span>).<span class="cm-property">length</span> <span class="cm-operator">></span> <span class="cm-number">0</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Unexpected text after program"</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>.<span class="cm-property">expr</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">parse</span>(<span class="cm-string">"+(a, 10)"</span>));
<span class="cm-comment">// → {type: "apply",</span>
<span class="cm-comment">//    operator: {type: "word", name: "+"},</span>
<span class="cm-comment">//    args: [{type: "word", name: "a"},</span>
<span class="cm-comment">//           {type: "value", value: 10}]}</span></pre>
<p><a class=p_ident id="p_44j4UwB2EL" href="#p_44j4UwB2EL"></a>It works! It doesn&#8217;t give us very helpful information when it fails,
and doesn&#8217;t store the line and column on which the expressions
started, which might be helpful when reporting errors later on, but it
is good enough for our purpose.</p>
<h2 id="_the_evaluator">The evaluator</h2>
<p><a class=p_ident id="p_NVE0gYIhuH" href="#p_NVE0gYIhuH"></a>What can we do with the syntax tree for a program? Run it, of course!
And that is what the evaluator does. You give it a syntax tree and an
environment—an object containing variable bindings—and it will
evaluate the expression that the tree represents and return the value
that this produces.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_dCjY/Lr6Wt" href="#c_dCjY/Lr6Wt"></a><span class="cm-keyword">function</span> <span class="cm-variable">evaluate</span>(<span class="cm-def">expr</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">switch</span>(<span class="cm-variable-2">expr</span>.<span class="cm-property">type</span>) {
    <span class="cm-keyword">case</span> <span class="cm-string">"value"</span>:
      <span class="cm-keyword">return</span> <span class="cm-variable-2">expr</span>.<span class="cm-property">value</span>;

    <span class="cm-keyword">case</span> <span class="cm-string">"word"</span>:
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">expr</span>.<span class="cm-property">name</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">env</span>)
        <span class="cm-keyword">return</span> <span class="cm-variable-2">env</span>[<span class="cm-variable-2">expr</span>.<span class="cm-property">name</span>];
      <span class="cm-keyword">else</span>
        <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">ReferenceError</span>(<span class="cm-string">"Undefined variable: "</span> <span class="cm-operator">+</span>
                                 <span class="cm-variable-2">expr</span>.<span class="cm-property">name</span>);
    <span class="cm-keyword">case</span> <span class="cm-string">"apply"</span>:
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">expr</span>.<span class="cm-property">operator</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"word"</span> <span class="cm-operator">&amp;&amp;</span>
          <span class="cm-variable-2">expr</span>.<span class="cm-property">operator</span>.<span class="cm-property">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">specialForms</span>)
        <span class="cm-keyword">return</span> <span class="cm-variable">specialForms</span>[<span class="cm-variable-2">expr</span>.<span class="cm-property">operator</span>.<span class="cm-property">name</span>](<span class="cm-variable-2">expr</span>.<span class="cm-property">args</span>,
                                                <span class="cm-variable-2">env</span>);
      <span class="cm-keyword">var</span> <span class="cm-def">op</span> <span class="cm-operator">=</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">expr</span>.<span class="cm-property">operator</span>, <span class="cm-variable-2">env</span>);
      <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">op</span> <span class="cm-operator">!=</span> <span class="cm-string">"function"</span>)
        <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">TypeError</span>(<span class="cm-string">"Applying a non-function."</span>);
      <span class="cm-keyword">return</span> <span class="cm-variable-2">op</span>.<span class="cm-property">apply</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">expr</span>.<span class="cm-property">args</span>.<span class="cm-property">map</span>(<span class="cm-keyword">function</span>(<span class="cm-def">arg</span>) {
        <span class="cm-keyword">return</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">arg</span>, <span class="cm-variable-2">env</span>);
      }));
  }
}

<span class="cm-keyword">var</span> <span class="cm-variable">specialForms</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);</pre>
<p><a class=p_ident id="p_BBPjU16P+4" href="#p_BBPjU16P+4"></a>The evaluator has code for each of the expression types. A literal
value expression simply produces its value. When running into a
variable, we must check that it is actually defined in the
environment, and if it is, fetch the variable&#8217;s value.</p>
<p><a class=p_ident id="p_rqT2TcyJaA" href="#p_rqT2TcyJaA"></a>Applications are more involved. If they are a special form, like <code>if</code>,
we do not evaluate anything, and simply pass the argument expressions,
along with the environment, to the function that handles this form. If
it is a normal call, we evaluate the operator, verify that it is a
function, and call it with the result of evaluating the arguments. We
will use plain JavaScript functions to represent function values in
the language.</p>
<p><a class=p_ident id="p_mzjyWqjcqM" href="#p_mzjyWqjcqM"></a>The the recursive structure of <code>evaluate</code> resembles the similar
structure of the parser. Both of them mirror the structure of the
language itself. It would also be possible to not separate the parser
from the evaluator, and evaluate during parsing, but splitting them up
makes the program easier to think about.</p>
<p><a class=p_ident id="p_KCiEkrz7n0" href="#p_KCiEkrz7n0"></a>This is really all that is needed to interpret a language. It is that
simple. Of course, without defining a few special forms, and adding
some useful values to the environment, you can&#8217;t do anything with the
language yet.</p>
<h2 id="_special_forms">Special forms</h2>
<p><a class=p_ident id="p_ImRWdbBRCE" href="#p_ImRWdbBRCE"></a>The <code>specialForms</code> object lets us look up the special constructs in
our language by name. It holds functions that interpret the construct.
It is currently empty. Let us add a few forms.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_keHNLB7iSD" href="#c_keHNLB7iSD"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"if"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">args</span>.<span class="cm-property">length</span> <span class="cm-operator">!=</span> <span class="cm-number">3</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Bad number of args to if"</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">0</span>], <span class="cm-variable-2">env</span>) <span class="cm-operator">!==</span> <span class="cm-atom">false</span>)
    <span class="cm-keyword">return</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">1</span>], <span class="cm-variable-2">env</span>);
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">return</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">2</span>], <span class="cm-variable-2">env</span>);
};</pre>
<p><a class=p_ident id="p_wGc5LHrEtx" href="#p_wGc5LHrEtx"></a>The <code>if</code> in this language expects exactly three arguments. It will
evaluate the first, and when the result isn&#8217;t the value <code>false</code>, it
will evaluate the second. Otherwise, the third gets evaluated. Because
<code>if</code> is an expression, not a statement, it has a value—namely the
result of the second or third argument.</p>
<p><a class=p_ident id="p_vffjCgqUgO" href="#p_vffjCgqUgO"></a>Our language differs from JavaScript in its handling of the condition
value to <code>if</code>—it will not treat 0 or the empty string as false, only
the precise value <code>false</code>.</p>
<p><a class=p_ident id="p_sH4/dJ+Quc" href="#p_sH4/dJ+Quc"></a>The reason we need to represent <code>if</code> as a special form, rather than a
regular function, is that functions receive their arguments in
evaluated form, but <code>if</code> must not evaluate all of its arguments.
Depending on the first argument, either the second or the third
remains unevaluated.</p>
<p><a class=p_ident id="p_Z67vCfZJi8" href="#p_Z67vCfZJi8"></a>The <code>while</code> form is similar;</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_YAC3A1f/Vo" href="#c_YAC3A1f/Vo"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"while"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">args</span>.<span class="cm-property">length</span> <span class="cm-operator">!=</span> <span class="cm-number">2</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Bad number of args to while"</span>);

  <span class="cm-keyword">while</span> (<span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">0</span>], <span class="cm-variable-2">env</span>) <span class="cm-operator">!==</span> <span class="cm-atom">false</span>)
    <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">1</span>], <span class="cm-variable-2">env</span>);

  <span class="cm-comment">// Since undefined does not exist in our language, and</span>
  <span class="cm-comment">// this form does not return a meaningful value, we</span>
  <span class="cm-comment">// return false.</span>
  <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
};</pre>
<p><a class=p_ident id="p_IgT4cyq/v7" href="#p_IgT4cyq/v7"></a>Another basic building block is <code>do</code>, which executes all its arguments
from top to bottom, and whose value is the value produced by the last
expression.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_C0SLsNu6uq" href="#c_C0SLsNu6uq"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"do"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">value</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
  <span class="cm-variable-2">args</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">arg</span>) {
    <span class="cm-variable-2">value</span> <span class="cm-operator">=</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">arg</span>, <span class="cm-variable-2">env</span>);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">value</span>;
};</pre>
<p><a class=p_ident id="p_C6o3zSjPya" href="#p_C6o3zSjPya"></a>To be able to create variables (and give them new values), we also
create a form called <code>define</code>, which expects a word as first argument,
and an expression producing the value to assign to that word as second
argument. Since it, like everything, is an expression, we make it
return the value that was assigned (just like JavaScripts “=”
operator).</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_4QghGMwc4p" href="#c_4QghGMwc4p"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"define"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">args</span>.<span class="cm-property">length</span> <span class="cm-operator">!=</span> <span class="cm-number">2</span> <span class="cm-operator">||</span> <span class="cm-variable-2">args</span>[<span class="cm-number">0</span>].<span class="cm-property">type</span> <span class="cm-operator">!=</span> <span class="cm-string">"word"</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Bad use of define"</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">value</span> <span class="cm-operator">=</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">1</span>], <span class="cm-variable-2">env</span>);
  <span class="cm-variable-2">env</span>[<span class="cm-variable-2">args</span>[<span class="cm-number">0</span>].<span class="cm-property">name</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">value</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">value</span>;
};</pre>
<h2 id="_the_environment">The environment</h2>
<p><a class=p_ident id="p_5FlZ6zgStt" href="#p_5FlZ6zgStt"></a>We have syntax for numbers and strings, but not for boolean values,
which we also want to support, if only to be able to use the <code>if</code>
construct we just defined.</p>
<p><a class=p_ident id="p_6P9zC9ukGK" href="#p_6P9zC9ukGK"></a>Since there are only two boolean values, we do not need special syntax
for them. We simply bind two variables to the values true and false,
and use those.</p>
<p><a class=p_ident id="p_DV0Zkqgoc7" href="#p_DV0Zkqgoc7"></a>The environment accepted by <code>evaluate</code> is an object with properties
whose names correspond to variable names, and whose values correspond
to the values those variables are bound to. Let us define an object to
represent the global scope, and add bindings for the boolean values.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_hR54TW9tph" href="#c_hR54TW9tph"></a><span class="cm-keyword">var</span> <span class="cm-variable">topEnv</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-variable">topEnv</span>[<span class="cm-string">"true"</span>] <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
<span class="cm-variable">topEnv</span>[<span class="cm-string">"false"</span>] <span class="cm-operator">=</span> <span class="cm-atom">false</span>;</pre>
<p><a class=p_ident id="p_XcUz3kuL0J" href="#p_XcUz3kuL0J"></a>We can now evaluate a simple expression that inverts a boolean value.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_U/qTEhm5kH" href="#c_U/qTEhm5kH"></a><span class="cm-keyword">var</span> <span class="cm-variable">prog</span> <span class="cm-operator">=</span> <span class="cm-variable">parse</span>(<span class="cm-string">"if(true, false, true)"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">evaluate</span>(<span class="cm-variable">prog</span>, <span class="cm-variable">topEnv</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class=p_ident id="p_zBgMw3fqND" href="#p_zBgMw3fqND"></a>To supply “primitive” functionality, such as arithmetic and comparison
operators, we will also add some functions to the environment. In the
interest of keeping the code short, we&#8217;ll use <code>new Function</code> to
synthesize a bunch of operator functions in a loop, rather than
defining them all individually.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Ucw1TBifIH" href="#c_Ucw1TBifIH"></a>[<span class="cm-string">"+"</span>, <span class="cm-string">"-"</span>, <span class="cm-string">"*"</span>, <span class="cm-string">"/"</span>, <span class="cm-string">"=="</span>, <span class="cm-string">"&lt;"</span>, <span class="cm-string">">"</span>].<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">op</span>) {
  <span class="cm-variable">topEnv</span>[<span class="cm-variable-2">op</span>] <span class="cm-operator">=</span>
    <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"a, b"</span>, <span class="cm-string">"return a "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">op</span> <span class="cm-operator">+</span> <span class="cm-string">" b;"</span>);
});</pre>
<p><a class=p_ident id="p_ZP9ZMJAskW" href="#p_ZP9ZMJAskW"></a>A way to output values is also very useful, so we wrap <code>console.log</code>
and call it <code>print</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_o0VLFoQzPE" href="#c_o0VLFoQzPE"></a><span class="cm-variable">topEnv</span>[<span class="cm-string">"print"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">value</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">value</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">value</span>;
};</pre>
<p><a class=p_ident id="p_LD0lewrgTF" href="#p_LD0lewrgTF"></a>That gives us the enough elementary tools to write simple programs.
The <code>run</code> function provides a convenient way to write them. It takes
care of parsing, creates a fresh environment, and evaluates the
strings we give it as a single program.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_hH6wAg7pwu" href="#c_hH6wAg7pwu"></a><span class="cm-keyword">function</span> <span class="cm-variable">run</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">env</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-variable">topEnv</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">program</span> <span class="cm-operator">=</span> <span class="cm-variable">Array</span>.<span class="cm-property">prototype</span>.<span class="cm-property">slice</span>
    .<span class="cm-property">call</span>(<span class="cm-variable-2">arguments</span>, <span class="cm-number">0</span>).<span class="cm-property">join</span>(<span class="cm-string">"\n"</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable">parse</span>(<span class="cm-variable-2">program</span>), <span class="cm-variable-2">env</span>);
}</pre>
<p><a class=p_ident id="p_BVEh1E58XI" href="#p_BVEh1E58XI"></a><code>Array.prototype.slice.call</code> is a trick to turn an array-like object,
such as <code>arguments</code> into a real array, so that we can call <code>join</code> on
it. It takes all the arguments given to <code>run</code>, and treats them as the
lines of a program.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_0Ro8WCoy2G" href="#c_0Ro8WCoy2G"></a><span class="cm-variable">run</span>(<span class="cm-string">"do(define(total, 0),"</span>,
    <span class="cm-string">"   define(count, 1),"</span>,
    <span class="cm-string">"   while(&lt;(count, 11),"</span>,
    <span class="cm-string">"         do(define(total, +(total, count)),"</span>,
    <span class="cm-string">"            define(count, +(count, 1)))),"</span>,
    <span class="cm-string">"   print(total))"</span>);
<span class="cm-comment">// → 55</span></pre>
<p><a class=p_ident id="p_4cQhF2ypgW" href="#p_4cQhF2ypgW"></a>This is the program that computes the total of the numbers 1 to 10,
expressed in our own language. It is clearly uglier than JavaScript,
but still not bad for a language implemented in less than 150 lines of
code.</p>
<h2 id="_functions">Functions</h2>
<p><a class=p_ident id="p_FabFt4VUPD" href="#p_FabFt4VUPD"></a>A programming language without functions is a poor programming
language indeed.</p>
<p><a class=p_ident id="p_yNEqxyKAuB" href="#p_yNEqxyKAuB"></a>Fortunately, we can easily add a <code>fun</code> construct, which treats its
last argument as the function&#8217;s body, and all arguments before that as
the names of the function&#8217;s arguments.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_3Dn8ryI9i3" href="#c_3Dn8ryI9i3"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"fun"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">args</span>.<span class="cm-property">length</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Functions need a body"</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">name</span>(<span class="cm-def">expr</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">expr</span>.<span class="cm-property">type</span> <span class="cm-operator">!=</span> <span class="cm-string">"word"</span>)
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Arg names must be words"</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable-2">expr</span>.<span class="cm-property">name</span>;
  }
  <span class="cm-keyword">var</span> <span class="cm-def">argNames</span> <span class="cm-operator">=</span> <span class="cm-variable-2">args</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">args</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>).<span class="cm-property">map</span>(<span class="cm-variable-2">name</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">body</span> <span class="cm-operator">=</span> <span class="cm-variable-2">args</span>[<span class="cm-variable-2">args</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>];

  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">argNames</span>.<span class="cm-property">length</span>)
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">TypeError</span>(<span class="cm-string">"Wrong number of arguments"</span>);
    <span class="cm-keyword">var</span> <span class="cm-def">localEnv</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-variable-2">env</span>);
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
      <span class="cm-variable-2">localEnv</span>[<span class="cm-variable-2">argNames</span>[<span class="cm-variable-2">i</span>]] <span class="cm-operator">=</span> <span class="cm-variable-2">arguments</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">return</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">body</span>, <span class="cm-variable-2">localEnv</span>);
  };
};</pre>
<p><a class=p_ident id="p_IlxImPKPxz" href="#p_IlxImPKPxz"></a>Functions, in our language, have their own local environment, just
like in JavaScript. We simply use <code>Object.create</code> to make a new object
that has access to the variables in the outer environment (its
prototype), but can also contain new variables without changing that
outer scope.</p>
<p><a class=p_ident id="p_8s1BSoLJ7h" href="#p_8s1BSoLJ7h"></a>The function created by the <code>fun</code> form creates this local environment,
and adds the argument variables to it. It then evaluates the function
body in this environment, and returns the result.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_ESQRrIyl/g" href="#c_ESQRrIyl/g"></a><span class="cm-variable">run</span>(<span class="cm-string">"do(define(plusOne, fun(a, +(a, 1))),"</span>,
    <span class="cm-string">"   print(+(plusOne(1), 2)))"</span>);
<span class="cm-comment">// → 4</span>

<span class="cm-variable">run</span>(<span class="cm-string">"do(define(pow, fun(base, exp,"</span>,
    <span class="cm-string">"     if(==(exp, 0),"</span>,
    <span class="cm-string">"        1,"</span>,
    <span class="cm-string">"        *(base, pow(base, -(exp, 1)))))),"</span>,
    <span class="cm-string">"   print(pow(2, 10)))"</span>);
<span class="cm-comment">// → 1024</span></pre>
<h2 id="_compilation">Compilation</h2>
<p><a class=p_ident id="p_5i/OCko4Ad" href="#p_5i/OCko4Ad"></a>What we have built is an interpreter. During evaluating, it acts
directly on the simple representation of the program that the parser
produced.</p>
<p><a class=p_ident id="p_O90ivKmGfR" href="#p_O90ivKmGfR"></a>Compilation is the process of adding another step in between, which
transforms the program into something that can be evaluated more
efficiently, by doing as much of the work as possible in advance. For
example, in well-designed languages it is obvious, for each use of a
variable, where the variable is defined, without actually running the
program. This can be used to avoid looking up the variable by name
every time it is accessed, and directly fetch it from its
predetermined memory location instead.</p>
<p><a class=p_ident id="p_HrQe0PuoCJ" href="#p_HrQe0PuoCJ"></a>Traditionally, compilation involves converting the program to machine
code, the raw format that a computer&#8217;s processor can execute. But any
process that converts a program to a different representation can be
thought of as compilation.</p>
<p><a class=p_ident id="p_+HfDnbf6cY" href="#p_+HfDnbf6cY"></a>It would be possible to write an alternative evaluation strategy for
our language, one that first converts the program to a JavaScript
program, uses <code>new Function</code> to invoke the JavaScript compiler on it,
and then runs that. When done right, this would make our language very
fast, while still being quite simple to implement.</p>
<h2 id="_cheating">Cheating</h2>
<p><a class=p_ident id="p_cUrg/8XPK+" href="#p_cUrg/8XPK+"></a>When we defined <code>if</code> and <code>while</code>, you probably noticed that they were
more or less trivial wrappers around JavaScript&#8217;s own <code>if</code> and
<code>while</code>. The values in our language are not wrapped at all, they are
regular old JavaScript values.</p>
<p><a class=p_ident id="p_hJgGHwW++B" href="#p_hJgGHwW++B"></a>If you compare the implementation of this language, built on top of
JavaScript, with the amount of work and complexity required to build a
programming language directly on the raw functionality provided by a
machine, the difference is huge. If the goal is programmer street
cred, this project is not very impressive.</p>
<p><a class=p_ident id="p_e7hDEkCUtU" href="#p_e7hDEkCUtU"></a>Regardless, I hope it illustrated the concepts involved. Many other
interesting concepts would come up when taking this project further,
but this is not a compiler writer&#8217;s book. If the topic interests you,
pick up such a book sometime, they are fascinating.</p>
<p><a class=p_ident id="p_G735mVHPzY" href="#p_G735mVHPzY"></a>But when it comes to getting something done, cheating is more
effective than doing everything yourself. Though the toy language in
this chapter doesn&#8217;t do anything that couldn&#8217;t be done better in
JavaScript, there <em>are</em> situations where writing small languages helps
get real work done.</p>
<p><a class=p_ident id="p_WIR6a1g/pa" href="#p_WIR6a1g/pa"></a>Such a language does not have to resemble a typical programming
language. If JavaScript would not come equipped with regular
expressions, you could write your own parser and evaluator for such a
sublanguage.</p>
<p><a class=p_ident id="p_j8SqlNkYB/" href="#p_j8SqlNkYB/"></a>Or, imagine you are building a giant robotic dinosaur, and need to
program it. JavaScript might not be the most effective way to do this,
and you might instead opt for a language that looks like this:</p>
<pre>behavior walk
  perform when
    destination ahead
  actions
    move left-foot
    move right-foot

behavior attack
  perform when
    Godzilla in-view
  actions
    fire laser-eyes
    launch arm-rockets</pre>
<p><a class=p_ident id="p_O9+2Ve51P4" href="#p_O9+2Ve51P4"></a>This is what is usually called a <em>domain-specific language</em>, a
language tailored to express a narrow domain of knowledge, which can
be more expressive than a general-purpose programming language because
it is designed to express exactly the things that need expressing in
its domain, and nothing else.</p>
<h2 id="_exercises">Exercises</h2>
<h3 id="_arrays">Arrays</h3>
<p><a class=p_ident id="p_4rt40yX+cU" href="#p_4rt40yX+cU"></a>Add support for arrays to our language, by adding the following three
functions to the top scope. Firstly <code>array(...)</code>, which constructs an
array containing the argument values. Secondly <code>length(array)</code>, to get
an array&#8217;s length. And finally, <code>element(array, n)</code> to fetch the n<sup>th</sup>
element from an array.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_NydxlNC9tJ" href="#c_NydxlNC9tJ"></a><span class="cm-comment">// Modify these definitions...</span>

<span class="cm-variable">topEnv</span>[<span class="cm-string">"array"</span>] <span class="cm-operator">=</span> <span class="cm-string">"..."</span>;

<span class="cm-variable">topEnv</span>[<span class="cm-string">"length"</span>] <span class="cm-operator">=</span> <span class="cm-string">"..."</span>;

<span class="cm-variable">topEnv</span>[<span class="cm-string">"element"</span>] <span class="cm-operator">=</span> <span class="cm-string">"..."</span>;

<span class="cm-variable">run</span>(<span class="cm-string">"do(define(sum, fun(array,"</span>,
    <span class="cm-string">"     do(define(i, 0),"</span>,
    <span class="cm-string">"        define(sum, 0),"</span>,
    <span class="cm-string">"        while(&lt;(i, length(array)),"</span>,
    <span class="cm-string">"          do(define(sum, +(sum, element(array, i))),"</span>,
    <span class="cm-string">"             define(i, +(i, 1)))),"</span>,
    <span class="cm-string">"        sum))),"</span>,
    <span class="cm-string">"   print(sum(array(1, 2, 3))))"</span>);
<span class="cm-comment">// → 6</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_31fDZBvLEa" href="#p_31fDZBvLEa"></a>The easiest way to do this is to represent the arrays in the language
with JavaScript arrays.</p>
<p><a class=p_ident id="p_+aiai7zl+b" href="#p_+aiai7zl+b"></a>The values added to the top environment must be functions. They take
the arguments that they are specified to take, and return values that
can be straightforwardly derived from their arguments.
<code>Array.prototype.slice</code> can be used to convert an <code>arguments</code>
pseudo-array into a regular array.</p>
</div></div>
<h3 id="_closure">Closure</h3>
<p><a class=p_ident id="p_dO5VwG516r" href="#p_dO5VwG516r"></a>The way we have defined <code>fun</code> allows functions in our language to
“close over” the surrounding environment, just like JavaScript
functions.</p>
<p><a class=p_ident id="p_DpEdeJwog6" href="#p_DpEdeJwog6"></a>The program below illustrates this—function <code>f</code> returns a function
that adds its argument to <code>f</code>'s argument, meaning that it needs access
to the local scope inside <code>f</code> to be able to use variable <code>a</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_zLDVGdi1HZ" href="#c_zLDVGdi1HZ"></a><span class="cm-variable">run</span>(<span class="cm-string">"do(define(f, fun(a, fun(b, +(a, b)))),"</span>,
    <span class="cm-string">"   print(f(4)(5)))"</span>);
<span class="cm-comment">// → 9</span></pre>
<p><a class=p_ident id="p_40Yj7LMkYl" href="#p_40Yj7LMkYl"></a>Go back to the definition of the <code>fun</code> form and explain which
mechanism causes this to work.</p>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_LOgpHZsyhJ" href="#p_LOgpHZsyhJ"></a>Again, we are riding along on a JavaScript mechanism to get the
equivalent feature in our own language. Special forms are passed the
local environment in which they are evaluated, so that they can
evaluate their sub-forms in that environment. The function returned by
<code>fun</code> closes over the <code>env</code> argument given to its enclosing function,
and uses that to create the function&#8217;s local environment when it is
called.</p>
<p><a class=p_ident id="p_w6RFAh/z4Z" href="#p_w6RFAh/z4Z"></a>This means that the prototype of the local environment will be the
environment in which the function was created, which makes it possible
to access variables in that environment from the function. This is all
there is to implementing closure (though to compile it in a way that
is actually efficient, you&#8217;d need to do some more work).</p>
</div></div>
<h3 id="_comments">Comments</h3>
<p><a class=p_ident id="p_9X10+SmA/k" href="#p_9X10+SmA/k"></a>It would be nice if we could write comments in our language. For
example, whenever a hash sign (“#”) is found, we could treat the rest of the
line as a comment (similar to “<code>//</code>” in JavaScript), ignoring it.</p>
<p><a class=p_ident id="p_EVGdU2vHLH" href="#p_EVGdU2vHLH"></a>We do not have to make any big changes to the parser to support this.
We can simply change <code>skipSpace</code> to skip comments as if they are
whitespace, so that all the points where <code>skipSpace</code> is called will
now also skip (ignore) comments. Make this change.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_H6x2Kymw5m" href="#c_H6x2Kymw5m"></a><span class="cm-comment">// This is the old skipSpace. Modify it...</span>
<span class="cm-keyword">function</span> <span class="cm-variable">skipSpace</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">first</span> <span class="cm-operator">=</span> <span class="cm-variable-2">string</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">first</span> <span class="cm-operator">==</span> <span class="cm-operator">-</span><span class="cm-number">1</span>) <span class="cm-keyword">return</span> <span class="cm-string">""</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">string</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">first</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">parse</span>(<span class="cm-string">"# hello\nx"</span>));
<span class="cm-comment">// → {type: "word", name: "x"}</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">parse</span>(<span class="cm-string">"a # one\n   # two\n()"</span>));
<span class="cm-comment">// → {type: "apply",</span>
<span class="cm-comment">//    operator: {type: "word", name: "x"},</span>
<span class="cm-comment">//    args: []}</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_Dds6GLJzwb" href="#p_Dds6GLJzwb"></a>Make sure your solution handles multiple comments in a row, with
potentially whitespace between or after them.</p>
<p><a class=p_ident id="p_w/PeZhCFV2" href="#p_w/PeZhCFV2"></a>A regular expression is probably the easiest way to solve this. Match
against something that matches “whitespace or a comment, zero or more
times” using the <code>exec</code> or <code>match</code> method, and then look at the length
of the first element in the returned array (the whole match) to find
out how many characters to slice off.</p>
</div></div>
<h3 id="_fixing_scope">Fixing scope</h3>
<p><a class=p_ident id="p_wiUendOwjA" href="#p_wiUendOwjA"></a>Currently, the only way to assign a variable a value is <code>define</code>. This
construct acts both as a way to define new variables and to give
existing ones a new value.</p>
<p><a class=p_ident id="p_CdB0leYpKl" href="#p_CdB0leYpKl"></a>That ambiguity causes a problem. When you try to give a non-local
variable a new value, you will end up defining a local one with the
same name instead. Some languages do work like this by design, but
I&#8217;ve always found it a silly way to handle scope.</p>
<p><a class=p_ident id="p_wCq6uGy4BL" href="#p_wCq6uGy4BL"></a>Add a special form <code>set</code>, similar to <code>define</code>, which gives a variable
a new value, updating the variable in an outer scope if it doesn&#8217;t
already exist in the inner scope. If the variable is not defined at
all, throw a <code>ReferenceError</code>.</p>
<p><a class=p_ident id="p_vI0CMB91dl" href="#p_vI0CMB91dl"></a>The technique of representing scopes as simple objects, which has made
things very convenient so far, will get in your way a little at this
point. You might want to use the <code>Object.getPrototypeOf</code> function,
which allows you to get the prototype of an object. Also remember that
scopes do not derive from <code>Object.prototype</code>, so if you want to call
<code>hasOwnProperty</code> on them, you have to use this clumsy expression:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_EqqjVhV5wE" href="#c_EqqjVhV5wE"></a><span class="cm-variable">Object</span>.<span class="cm-property">prototype</span>.<span class="cm-property">hasOwnProperty</span>.<span class="cm-property">call</span>(<span class="cm-variable">scope</span>, <span class="cm-variable">name</span>);</pre>
<p><a class=p_ident id="p_xdKe490o5g" href="#p_xdKe490o5g"></a>This fetches the <code>hasOwnProperty</code> method from the <code>Object</code> prototype,
and then calls it on a scope object.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_KcPg7PsN3m" href="#c_KcPg7PsN3m"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"set"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-comment">// Your code here.</span>
};

<span class="cm-variable">run</span>(<span class="cm-string">"do(define(x, 4),"</span>,
    <span class="cm-string">"   define(setx, fun(val, set(x, val))),"</span>,
    <span class="cm-string">"   setx(50),"</span>,
    <span class="cm-string">"   print(x))"</span>);
<span class="cm-comment">// → 50</span>
<span class="cm-variable">run</span>(<span class="cm-string">"set(quux, true)"</span>);
<span class="cm-comment">// → Some kind of ReferenceError</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_NhXhfFLedb" href="#p_NhXhfFLedb"></a>You will have to loop through one scope at a time, using
<code>Object.getPrototypeOf</code> to go the next outer scope. For each scope,
use <code>hasOwnProperty</code> to find out if the variable, indicated by the
<code>name</code> property of the first argument to <code>set</code>, exists in that scope.
If it does, set it to the result of evaluating the second argument to
<code>set</code>, and return that value.</p>
<p><a class=p_ident id="p_2jadkVt6qG" href="#p_2jadkVt6qG"></a>When the outermost scope is reached (<code>Object.getPrototypeOf</code> returns
null) and we haven&#8217;t found the variable yet, it does not exist, and an
error should be thrown.</p>
</div></div>
<nav>
  <a href="10_modules.html" title="previous chapter">⬅</a>
  <a href="index.html" title="cover">⬆</a>
  <a href="12_browser.html" title="next chapter">➡</a>
</nav>
</article>
