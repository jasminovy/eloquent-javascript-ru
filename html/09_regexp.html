<!doctype html>
<head>
  <meta charset="utf-8">
  <title>Regular Expressions :: Eloquent JavaScript</title>
  <link rel=stylesheet href="../node_modules/codemirror/lib/codemirror.css">
  <script src="../node_modules/codemirror/lib/codemirror.js"></script>
  <script src="../node_modules/codemirror/mode/javascript/javascript.js"></script>
  <script src="../node_modules/codemirror/mode/css/css.js"></script>
  <script src="../node_modules/codemirror/mode/xml/xml.js"></script>
  <script src="../node_modules/codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <script src="../node_modules/codemirror/addon/edit/matchbrackets.js"></script>
  <script src="../node_modules/acorn/acorn.js"></script>
  <script src="../node_modules/acorn/util/walk.js"></script>
  <link rel=stylesheet href="ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 9;</script>
</head>

<article>
<nav>
  <a href="08_error.html" title="previous chapter">⬅</a>
  <a href="index.html" title="cover">⬆</a>
  <a href="10_modules.html" title="next chapter">➡</a>
</nav>

<h1><div class=chap_num>Chapter 9</div>Regular Expressions</h1>
<blockquote>
<p><a class=p_ident id="p_MWUwIAb0uO" href="#p_MWUwIAb0uO"></a>Some people, when confronted with a problem, think ‘I know, I&#8217;ll use
regular expressions.’ Now they have two problems.</p>
 <footer>Jamie Zawinski</footer>
</blockquote>
<blockquote>
<p><a class=p_ident id="p_icxlw7+18l" href="#p_icxlw7+18l"></a>Yuan-Ma said, ‘When you cut against the grain of the wood, much
strength is needed. When you program against the grain of a problem,
much code is needed.’</p>
 <footer>Master Yuan-Ma, <cite>The Book of Programming</cite></footer>
</blockquote>
<p><a class=p_ident id="p_spKOfnKUb5" href="#p_spKOfnKUb5"></a>The way programming conventions and techniques survive and spread
happens in a chaotic, evolutionary way. It&#8217;s not usually the pretty or
brilliant ones that win, but rather the ones that combine working
passably well with sitting in the right niche—for example by being
integrated with another successful piece of technology.</p>
<p><a class=p_ident id="p_2ySNBCvXNS" href="#p_2ySNBCvXNS"></a>In this chapter I will discuss one such technology, <em>regular
expressions</em>. Regular expressions are a way to describe patterns in
string data. They form a small, separate language that is part of
JavaScript (as well as various other programming languages and tools).</p>
<p><a class=p_ident id="p_IjlKS2efJw" href="#p_IjlKS2efJw"></a>Regular expressions are both extremely useful and terribly awkward.
Learning them properly will make it much easier to inspect and process
strings. Unfortunately, the syntax used for these expressions is
cryptic, and the programming interface JavaScript provides for them is
clumsy.</p>
<h2 id="_notation">Notation</h2>
<p><a class=p_ident id="p_U7bwSfeOl6" href="#p_U7bwSfeOl6"></a>A regular expression is an object. It can either be constructed with
the <code>RegExp</code> constructor or written as a literal value by enclosing
the pattern in slash (“/”) characters.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_XBSA9s2btm" href="#c_XBSA9s2btm"></a><span class="cm-keyword">var</span> <span class="cm-variable">re1</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">"abc"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">re2</span> <span class="cm-operator">=</span> <span class="cm-string-2">/abc/</span>;</pre>
<p><a class=p_ident id="p_RqIniH0qmH" href="#p_RqIniH0qmH"></a>Such an object represents a pattern. In this case, the pattern is an
“a” character followed by a “b” followed by a “c”.</p>
<p><a class=p_ident id="p_yIYXXdvK6c" href="#p_yIYXXdvK6c"></a>When using the <code>RegExp</code> constructor, the pattern is written as a
normal string, so the usual rules apply for backslashes. In the second
notation, we are using slashes to delimit the pattern, so we&#8217;d have to
backslash-escape slash characters that are part of the pattern. Some
other characters, such as question marks and plus signs, are used as
special markers in regular expressions, and must to be preceded by a
backslash if they are meant to represent the character itself.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Tux1ufLYv1" href="#c_Tux1ufLYv1"></a><span class="cm-keyword">var</span> <span class="cm-variable">onePlusOne</span> <span class="cm-operator">=</span> <span class="cm-string-2">/1 \+ 1/</span>;</pre>
<p><a class=p_ident id="p_GYUjU5Z/Gb" href="#p_GYUjU5Z/Gb"></a>Knowing precisely what characters to backslash-escape when writing
regular expressions requires you to know about all the special meaning
assigned to characters by this syntax. For the time being, this may
not be realistic, so when in doubt, just put a backslash before any
character that is not a letter, number, or whitespace.</p>
<h2 id="_testing_for_matches">Testing for matches</h2>
<p><a class=p_ident id="p_OTzSdV6RdS" href="#p_OTzSdV6RdS"></a>Regular expression objects have a number of methods.
The simplest one is <code>test</code>. If you pass it a string, it will tell you
whether the pattern contained in the expression matches the string,
returning a boolean.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_O53a6v4BM0" href="#c_O53a6v4BM0"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/abc/</span>.<span class="cm-property">test</span>(<span class="cm-string">"abcde"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/abc/</span>.<span class="cm-property">test</span>(<span class="cm-string">"abxde"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class=p_ident id="p_WFokgkkjHh" href="#p_WFokgkkjHh"></a>A regular expression consisting of only non-special characters simply
represents that sequence of characters. If “abc” occurs anywhere in
the string we are testing against (not just at the start), <code>test</code> will
return <code>true</code>.</p>
<h2 id="_matching_a_set_of_characters">Matching a set of characters</h2>
<p><a class=p_ident id="p_DtXmb/uhsO" href="#p_DtXmb/uhsO"></a>Finding out whether a string contains “abc” could
just as well be done with a call to <code>indexOf</code>. Regular expressions
allow us to go beyond that, and express more complicated patterns.</p>
<p><a class=p_ident id="p_i/99SEfu9y" href="#p_i/99SEfu9y"></a>Say we want to match any number. In a regular expression, putting a
set of characters between square brackets makes that part of the
expression match any of the characters between the brackets.</p>
<p><a class=p_ident id="p_qvDmrflKtj" href="#p_qvDmrflKtj"></a>The expressions below matches all strings that contains a digit.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_lup2c3o+xm" href="#c_lup2c3o+xm"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/[0123456789]/</span>.<span class="cm-property">test</span>(<span class="cm-string">"in 1992"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/[0-9]/</span>.<span class="cm-property">test</span>(<span class="cm-string">"in 1992"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_wRtlqwOjaP" href="#p_wRtlqwOjaP"></a>Between square brackets, a dash (“-”) between two
characters can be used to indicate a range of characters, where the
ordering is determined by the character&#8217;s Unicode code points.
Characters “0” to “9” sit right next to each other in this ordering
(codes 48 to 57), so <code>[0-9]</code> covers all of them, and matches any
digit.</p>
<p><a class=p_ident id="p_+w4wbahJfo" href="#p_+w4wbahJfo"></a> There are a number of commonly use character groups that
have their own built-in shortcuts. Digits are one of them—backslash-d
(<code>\d</code>) means the same thing as <code>[0-9]</code>.</p>
<table>
<tr>
<td><code>\d</code></td>
<td>Digit characters</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>Alphanumeric characters (“word characters”)</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>Whitespace characters (space, tab, newline, and similar)</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>Characters that are <em>not</em> digits</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>Non-alphanumeric characters</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>Non-whitespace characters</td>
</tr>
<tr>
<td><code>.</code></td>
<td>A period matches all characters except newlines</td>
</tr>
</table>
<p><a class=p_ident id="p_/DRpiD8jKa" href="#p_/DRpiD8jKa"></a>For each of the backslash-prefixed categories, there is an uppercase
variant that means the exact opposite.</p>
<p><a class=p_ident id="p_yXMUKEYpwG" href="#p_yXMUKEYpwG"></a>So you could express a date and time format like “30-01-2003 15:20” with
the following expression:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_vXh+CdcvKs" href="#c_vXh+CdcvKs"></a><span class="cm-keyword">var</span> <span class="cm-variable">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d\d-\d\d-\d\d\d\d \d\d:\d\d/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">"30-01-2003 15:20"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">"30-jan-2003 15:20"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class=p_ident id="p_uVsVmp/GjY" href="#p_uVsVmp/GjY"></a>Looks completely awful, doesn&#8217;t it? Way too many
backslashes, producing a background noise that makes it hard to spot
the actual pattern expressed. We&#8217;ll see a slightly improved version of
this expression later on.</p>
<p><a class=p_ident id="p_llxfpV2egw" href="#p_llxfpV2egw"></a>These category markers can also be used inside of square brackets, for
example <code>[\d\.]</code> means any digit or a dot.</p>
<p><a class=p_ident id="p_HqQEZsitdl" href="#p_HqQEZsitdl"></a>To <em>invert</em> a set of characters, i.e. to express that you want to match any
character <em>except</em> the ones in the set, a caret (“^”) character is
written after the opening bracket.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_ExU1Fm09+X" href="#c_ExU1Fm09+X"></a><span class="cm-keyword">var</span> <span class="cm-variable">notBinary</span> <span class="cm-operator">=</span> <span class="cm-string-2">/[^01]/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">notBinary</span>.<span class="cm-property">test</span>(<span class="cm-string">"1100100010100110"</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">notBinary</span>.<span class="cm-property">test</span>(<span class="cm-string">"1100100010200110"</span>));
<span class="cm-comment">// → true</span></pre>
<h2 id="_repeating_parts_of_a_pattern">Repeating parts of a pattern</h2>
<p><a class=p_ident id="p_crYiu/oAUM" href="#p_crYiu/oAUM"></a>We now know how to match a single digit. What if we want to match a
whole number—a sequence of one or more digits?</p>
<p><a class=p_ident id="p_B4wupHzbR+" href="#p_B4wupHzbR+"></a>When you put
a plus sign (“+”) after something in a regular expression, that
indicates that it may be repeated more than once. Thus, <code>/\d+/</code>
matches one or more digit characters.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_gPOZZi5uor" href="#c_gPOZZi5uor"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d+'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"'123'"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d+'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"''"</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d*'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"'123'"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d*'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"''"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_/oNBIVm41F" href="#p_/oNBIVm41F"></a>The star (“<code>*</code>”) has a similar meaning, but also allows the pattern to
match zero times. Something with a star after it never prevents a
pattern from matching—it&#8217;ll just match zero instances if it can&#8217;t find
any suitable text to match.</p>
<p><a class=p_ident id="p_rtXbvQjQpG" href="#p_rtXbvQjQpG"></a>A question mark makes a part of a pattern “optional”, meaning it may
occur zero or one times. In the following example, the “u” character
is allowed to occur, but the pattern also matches when it is missing.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Jvdrjd3WXF" href="#c_Jvdrjd3WXF"></a><span class="cm-keyword">var</span> <span class="cm-variable">neighbor</span> <span class="cm-operator">=</span> <span class="cm-string-2">/neighbou?r/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">neighbor</span>.<span class="cm-property">test</span>(<span class="cm-string">"neighbour"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">neighbor</span>.<span class="cm-property">test</span>(<span class="cm-string">"neighbor"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_3ZCM0cX0WB" href="#p_3ZCM0cX0WB"></a>To allow a pattern to occur a precisely defined number of times, curly
braces are used. Putting <code>{4}</code> after an element requires it to occur
exactly four times. Similarly, <code>{2,4}</code> is used when the element must
occur at least twice, and at most four times.</p>
<p><a class=p_ident id="p_awR6bPYROd" href="#p_awR6bPYROd"></a>Here is another version of the date and time pattern. It allows
single-digit day, month, and hour numbers, and is slightly more
readable:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_mwpr5hmR0y" href="#c_mwpr5hmR0y"></a><span class="cm-keyword">var</span> <span class="cm-variable">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">"30-1-2003 8:45"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_FUHbhTkfrd" href="#p_FUHbhTkfrd"></a>It is also possible to leave either the minimum or the maximum amount
of occurrences open-ended, by omitting the number on one side of the
comma. So <code>{,5}</code> means zero to five times, and <code>{5,}</code> means five or
more times.</p>
<h2 id="_grouping_sub_expressions">Grouping sub-expressions</h2>
<p><a class=p_ident id="p_pKTOYUDGIr" href="#p_pKTOYUDGIr"></a>To use an operator like “<code>*</code>” or “+” on more
than one element at a time, we can use parentheses. A part of a
regular expression that is surrounded in parentheses counts as a
single element as far as the operators following it are concerned.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_mLfHSPalKV" href="#c_mLfHSPalKV"></a><span class="cm-keyword">var</span> <span class="cm-variable">cartoonCrying</span> <span class="cm-operator">=</span> <span class="cm-string-2">/boo+(hoo+)+/i</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">cartoonCrying</span>.<span class="cm-property">test</span>(<span class="cm-string">"Boohoooohoohooo"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class=p_ident id="p_xfm8f+jhjn" href="#p_xfm8f+jhjn"></a>The third “+” applies to the whole group <code>(hoo+)</code>, matching one or
more sequences like that.</p>
<p><a class=p_ident id="p_tFxtn8Pxg1" href="#p_tFxtn8Pxg1"></a>The “i” at the end of the expression in
the example above makes this regular expression case-insensitive,
allowing it to match the uppercase “B” in the input string, even
though the pattern is itself all lowercase.</p>
<h2 id="_matches_and_groups">Matches and groups</h2>
<p><a class=p_ident id="p_K4AlKPLvyA" href="#p_K4AlKPLvyA"></a>The <code>test</code> method is the absolute simplest way to match a regular
expression. It only tells you whether it matched, and nothing else.
Regular expressions also have an <code>exec</code> (execute) method, that will
return <code>null</code> when no match was found, and an object with information
about the match otherwise.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_YvQYsEnL/O" href="#c_YvQYsEnL/O"></a><span class="cm-keyword">var</span> <span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d+/</span>.<span class="cm-property">exec</span>(<span class="cm-string">"one two 100"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>);
<span class="cm-comment">// → ["100"]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → 8</span></pre>
<p><a class=p_ident id="p_wPKWj89Kii" href="#p_wPKWj89Kii"></a>String values have a <code>match</code> method that behaves
very similarly.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_yvsDvKWBej" href="#c_yvsDvKWBej"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"one two 100"</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/\d+/</span>));
<span class="cm-comment">// → ["100"]</span></pre>
<p><a class=p_ident id="p_fJSwbQyG6w" href="#p_fJSwbQyG6w"></a>An object returned from <code>exec</code> or <code>match</code> has an
<code>index</code> property that tells us <em>where</em> in the string the successful
match started. Other than that, the object looks like (and in fact is)
an array of strings, whose first element is the string that was
matched—in the example above, that is the sequence of digits that we
were looking for.</p>
<p><a class=p_ident id="p_fFGmBROT0i" href="#p_fFGmBROT0i"></a>When the regular expression contains sub-expressions grouped with
parentheses, the text that matched those groups will also show up in
the array. The whole match is always the first element. The next
element is the part matched by the first group (the one whose opening
parenthesis comes first in the expression), then the second, and so
on.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_HNCJk6hb0+" href="#c_HNCJk6hb0+"></a><span class="cm-keyword">var</span> <span class="cm-variable">quotedText</span> <span class="cm-operator">=</span> <span class="cm-string-2">/'([^']*)'/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">quotedText</span>.<span class="cm-property">exec</span>(<span class="cm-string">"she said 'hello'"</span>));
<span class="cm-comment">// → ["'hello'", "hello"]</span></pre>
<p><a class=p_ident id="p_f4bciMASJ1" href="#p_f4bciMASJ1"></a>When a group does not end up being matched at all (for example when
followed by a question mark), its position in the output array will
hold <code>undefined</code>. Similarly, when a group is matched multiple times,
only the last match ends up in the array.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_z3tMpYKOai" href="#c_z3tMpYKOai"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/bad(ly)?/</span>.<span class="cm-property">exec</span>(<span class="cm-string">"bad"</span>));
<span class="cm-comment">// → ["bad", undefined]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/(\d)+/</span>.<span class="cm-property">exec</span>(<span class="cm-string">"123"</span>));
<span class="cm-comment">// → ["123", "3"]</span></pre>
<p><a class=p_ident id="p_zGhL5UaDaO" href="#p_zGhL5UaDaO"></a>Groups can be very useful for extracting parts of a string. If we do
not just want to verify whether a string contains a date, but also
extract it and construct an object that represents it, we can wrap
parentheses around the digit patterns, and directly pick them out of
the result of <code>exec</code>.</p>
<p><a class=p_ident id="p_Yfg3xaTrge" href="#p_Yfg3xaTrge"></a>But first, a brief detour.</p>
<h2 id="_the_date_type">The date type</h2>
<p><a class=p_ident id="p_2NeTRvucQq" href="#p_2NeTRvucQq"></a>JavaScript has a standard object type for representing dates—or
rather, points in time. It is called <code>Date</code>. If you simply create a
date object using <code>new</code>, you get the current date and time.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_GCz2vhG9tO" href="#c_GCz2vhG9tO"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>());
<span class="cm-comment">// → Wed Dec 04 2013 14:24:57 GMT+0100 (CET)</span></pre>
<p><a class=p_ident id="p_IcV7kv3B1y" href="#p_IcV7kv3B1y"></a>You can also create an object for a specific time.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_SlUeqLFk0N" href="#c_SlUeqLFk0N"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2009</span>, <span class="cm-number">11</span>, <span class="cm-number">9</span>));
<span class="cm-comment">// → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2009</span>, <span class="cm-number">11</span>, <span class="cm-number">9</span>, <span class="cm-number">12</span>, <span class="cm-number">59</span>, <span class="cm-number">59</span>, <span class="cm-number">999</span>));
<span class="cm-comment">// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)</span></pre>
<p><a class=p_ident id="p_3P1Nh5Y+3T" href="#p_3P1Nh5Y+3T"></a>JavaScript uses a convention where month numbers start at zero (so
December is 11), yet day numbers start at one. This is confusing and
silly. Be careful.</p>
<p><a class=p_ident id="p_gVdQSb0Lv9" href="#p_gVdQSb0Lv9"></a>The last four arguments (hours, minutes, seconds, and milliseconds)
are optional, and taken to be zero when not given.</p>
<p><a class=p_ident id="p_2owy14wm6k" href="#p_2owy14wm6k"></a>Timestamps are in fact stored as the number of milliseconds since the
start of 1970. The <code>getTime</code> method on a date object returns this
number. It is big, as you can imagine.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_eWYgxNiBDF" href="#c_eWYgxNiBDF"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2013</span>, <span class="cm-number">11</span>, <span class="cm-number">19</span>).<span class="cm-property">getTime</span>());
<span class="cm-comment">// → 1387407600000</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">1387407600000</span>));
<span class="cm-comment">// → Thu Dec 19 2013 00:00:00 GMT+0100 (CET)</span></pre>
<p><a class=p_ident id="p_6LnHuFRwKd" href="#p_6LnHuFRwKd"></a>When giving the <code>Date</code> constructor a single argument, that argument is
treated as such a millisecond number.</p>
<p><a class=p_ident id="p_OMuHPQoSyh" href="#p_OMuHPQoSyh"></a>Date objects provide methods like <code>getFullYear</code>, <code>getMonth</code>,
<code>getDate</code>, <code>getHours</code>, <code>getMinutes</code>, and <code>getSeconds</code> to extract their
components. There&#8217;s also <code>getYear</code>, which gives you a rather useless
two-digit year value (such as <code>93</code> or <code>14</code>).</p>
<p><a class=p_ident id="p_o8LeTN45ov" href="#p_o8LeTN45ov"></a>So now, putting parentheses around the parts of the expression that we
are interested in, we can easily extract a date from a string.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_tDkVEySAJp" href="#c_tDkVEySAJp"></a><span class="cm-keyword">function</span> <span class="cm-variable">findDate</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/(\d{1,2})-(\d{1,2})-(\d{4})/</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">dateTime</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">string</span>);
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">3</span>]),
                  <span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">2</span>]),
                  <span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">1</span>]));
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">findDate</span>(<span class="cm-string">"30-1-2003"</span>));
<span class="cm-comment">// → Sun Mar 02 2003 00:00:00 GMT+0100 (CET)</span></pre>
<h2 id="_word_and_string_boundaries">Word and string boundaries</h2>
<p><a class=p_ident id="p_4Z0WhKLfjo" href="#p_4Z0WhKLfjo"></a>The <code>findDate</code> function will also happily extract a date from the
string <code>"100-1-30000"</code>—a match may happen anywhere in the string, so
in this case it&#8217;ll just start at the second character and end at the
one-but-last.</p>
<p><a class=p_ident id="p_tKA0/BuA/v" href="#p_tKA0/BuA/v"></a>If we want to enforce that the match must span
the whole string, we can add the markers “^” and “$”. The first
matches the start of the input string, and the second the end. So
<code>/^\d+$/</code> matches a string consisting entirely of one or more digits,
<code>/^!/</code> matches any string that starts with an exclamation mark, and
<code>/x^/</code> does not match any string (there can not be an “x” <em>before</em> the
start of the string).</p>
<p><a class=p_ident id="p_dWIgppHuON" href="#p_dWIgppHuON"></a>If, on the other hand, we just want to
make sure the date starts and ends on a word boundary, we can use the
marker <code>\b</code>. A word boundary can be the start or end of the string, or
any point in the string that has a word character (as in <code>\w</code>) on one
side, and a non-word character on the other.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_78q/iu+Tt7" href="#c_78q/iu+Tt7"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/cat/</span>.<span class="cm-property">test</span>(<span class="cm-string">"concatenate"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\bcat\b/</span>.<span class="cm-property">test</span>(<span class="cm-string">"concatenate"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class=p_ident id="p_9J6Alc076F" href="#p_9J6Alc076F"></a>Note that these boundary markers don&#8217;t <em>cover</em> any actual characters,
they just enforce that the pattern only matches when a certain
condition holds at the place where they appear.</p>
<h2 id="_alternatives">Alternatives</h2>
<p><a class=p_ident id="p_WoVEzGZ2CJ" href="#p_WoVEzGZ2CJ"></a>Next, we want to know whether a piece of text contains not only a
number, but a number followed by one of the words “pig”, “cow”, or
“chicken”, or their plural forms.</p>
<p><a class=p_ident id="p_GcEbQJT+nS" href="#p_GcEbQJT+nS"></a>We could write three regular expressions, and test them in turn, but
there is a nicer way. The pipe character (“<code>|</code>”) denotes a choice
between the pattern to its left and the pattern to its right. So I can
say this:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_T1BADhqiD4" href="#c_T1BADhqiD4"></a><span class="cm-keyword">var</span> <span class="cm-variable">animalCount</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\b\d+ (pig|cow|chicken)s?\b/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">animalCount</span>.<span class="cm-property">test</span>(<span class="cm-string">"15 pigs"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">animalCount</span>.<span class="cm-property">test</span>(<span class="cm-string">"15 pigchickens"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class=p_ident id="p_+vG2bBcznO" href="#p_+vG2bBcznO"></a>Parentheses can be used to limit the part of the pattern that the pipe
operator applies to, and you can put multiple such operators next to
each other to express a choice between more than two patterns.</p>
<h2 id="_the_mechanics_of_matching">The mechanics of matching</h2>
<p><a class=p_ident id="p_fSpOFXMKY0" href="#p_fSpOFXMKY0"></a>Regular expressions can be thought of as flow diagrams. This is the
diagram for the livestock expression in the previous example:</p>
<div class="image">
  <img src="img/re_pigchickens.svg" alt="Visualization of /\d+ (pig|cow|chicken)s?/">
</div>
<p><a class=p_ident id="p_5/V5fXPX5H" href="#p_5/V5fXPX5H"></a>A string matches the expression if a path from the start (left) to the
end (right) of the diagram can be found, with a corresponding start
and end position in the string, such that every time we go through a
box, we verify that our current position in the string corresponds to
the element described by the box and, for elements that match actual
characters (which the word boundaries do not), move our position
forward.</p>
<p><a class=p_ident id="p_5MAs5GpsFt" href="#p_5MAs5GpsFt"></a>So if we match <code>"the 3 pigs"</code> there is a match between positions 4
(the digit “3”) and 10 (the end of the string).</p>
<div class="ulist"><ul>
<li>
<p>
At position 4, there is a word boundary, so we can move past the
   first box.
</p>
</li>
<li>
<p>
Still at position 4, we find a digit, so we can also move past the
   second box.
</p>
</li>
<li>
<p>
At position 5, we could go back to before the second (digit) box,
   or move forward through the box that holds a single space
   character. There is a space here, not a digit, so we choose the
   second path.
</p>
</li>
<li>
<p>
We are now at position 6 (the start of “pigs”) and at the three-way
   branch in the diagram. We don&#8217;t see “cow” or “chicken” here, but we
   do see “pig”, so we take that branch.
</p>
</li>
<li>
<p>
At position 9, after the three-way branching, we could either skip
   the “s” box and go straight to the final word boundary, or first
   match an “s”. There is an “s” character here, not a word boundary,
   so we go through the “s” box.
</p>
</li>
<li>
<p>
We&#8217;re at position 10 (end of the string) and can only match a word
   boundary. The end of a string counts as a word boundary, so we go
   through the last box and have successfully matched this string.
</p>
</li>
</ul></div>
<p><a class=p_ident id="p_dfwI9Viw95" href="#p_dfwI9Viw95"></a>Conceptually, a regular expression engine looks for a match in a
string as follows: it starts at the start of the string and tries a
match there. In this case, there <em>is</em> a word boundary there, so it&#8217;d
get past the first box, but there is no digit, so it&#8217;d fail at the
second box. Then it moves on to the second character in the string,
and tries there. And so on, until it finds a match, or reaches the end
of the string and decides that there really is no match.</p>
<h2 id="_backtracking">Backtracking</h2>
<p><a class=p_ident id="p_tCd15MFAty" href="#p_tCd15MFAty"></a>The regular expression <code>/\b([01]+b|\d+|[\da-f]h)\b/</code>
matches either a binary number followed by a “b”, a regular decimal
number without suffix character, or a hexadecimal number (base 16,
with the letters “a” to “f” standing for the digits 10 to 15) followed
by an “h”. This is the corresponding diagram:</p>
<div class="image">
  <img src="img/re_number.svg" alt="Visualization of /([01]+b|\d+|[\da-f]h)/">
</div>
<p><a class=p_ident id="p_CkxEfo2iHH" href="#p_CkxEfo2iHH"></a>When matching this expression, it will often happen that the top
(binary) branch is entered although the input does not actually
contain a binary number. When matching the string <code>"103"</code>, it is only
at the “3” that it becomes clear that we are in the wrong branch. The
string does match the expression, just not the branch we are currently
in.</p>
<p><a class=p_ident id="p_DxYunZsHTy" href="#p_DxYunZsHTy"></a>What happens then is that the matcher <em>backtracks</em>. When entering a
branch, it remembers where it was when it entered the current branch
(in this case, at the start of the string, just past the first
boundary box in the diagram), so that it can go back and try another
branch if the current one does not work out. So for the string
<code>"103"</code>, after encountering the “3” character, it will start trying
the decimal (second) branch. This one matches, so a match is reported
after all.</p>
<p><a class=p_ident id="p_kn4bA+SFZL" href="#p_kn4bA+SFZL"></a>When a full match is found, the matcher is done. That means that if
multiple branches would match a string, the first one (in the order in
which they appear in the regular expression) is the one that is used.</p>
<p><a class=p_ident id="p_zEBIV8lYeb" href="#p_zEBIV8lYeb"></a>Backtracking also happens, in a slightly different form, for repeat
operators. If you match <code>/^.*x/</code> against <code>"abcxe"</code>, the <code>.*</code> part will
first try to consume the whole string. The engine will then realize
that it needs an “x” to match the pattern. Since there is no “x” past
the end of the string, the star operator tries to match one character
less. And then another character less. And <em>now</em> it finds an “x” where
it needs it, and reports a successful match from position 0 to 4.</p>
<p><a class=p_ident id="p_VxCrsg7UEp" href="#p_VxCrsg7UEp"></a>It is possible to write regular expressions that will do a <em>lot</em> of
backtracking. This problem occurs when a pattern can match a piece of
input in many different ways. For example, if we get confused while
writing our binary-number regexp and accidentally write something like
<code>/([01]+)+b/</code>.</p>
<div class="image">
  <img src="img/re_slow.svg" alt="Visualization of /([01]+)+b/">
</div>
<p><a class=p_ident id="p_5cI0Ma3Wy8" href="#p_5cI0Ma3Wy8"></a>If that tries to match some long series of zeroes and ones <em>without</em> a
“b” character after them, it will first go through the inner loop
until it runs out of digits. Then it notices there is no “b”, so it
backtracks one position, goes through the <em>outer</em> loop once, and give
up again, trying to backtrack out of the inner loop once more. It will
continue to try every possible route through these two loops, which
means the amount of work it needs to do doubles with each additional
character. For a few dozen characters, the resulting match will
already take practically forever.</p>
<h2 id="_the_replace_method">The replace method</h2>
<p><a class=p_ident id="p_HMQv5qrs78" href="#p_HMQv5qrs78"></a>String values
have a <code>replace</code> method, which can be used to replace a part of the
string with another string.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_k4SqDNUcsT" href="#c_k4SqDNUcsT"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"papa"</span>.<span class="cm-property">replace</span>(<span class="cm-string">"p"</span>, <span class="cm-string">"m"</span>));
<span class="cm-comment">// → mapa</span></pre>
<p><a class=p_ident id="p_sFaaX02NA9" href="#p_sFaaX02NA9"></a>The first argument can also be a regular expression, in which case the
first match of the regular expression is replaced.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_L+rdP1BZ/D" href="#c_L+rdP1BZ/D"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Borobudur"</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[ou]/</span>, <span class="cm-string">"a"</span>));
<span class="cm-comment">// → Barobudur</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Borobudur"</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[ou]/g</span>, <span class="cm-string">"a"</span>));
<span class="cm-comment">// → Barabadar</span></pre>
<p><a class=p_ident id="p_rBqbX9mLP3" href="#p_rBqbX9mLP3"></a>When a “g” option (for “global”) is added to the regular expression,
<em>all</em> matches in the string will be replaced, not just the first.</p>
<p><a class=p_ident id="p_k90SO6OTUP" href="#p_k90SO6OTUP"></a>It would have been sensible if the choice between replacing one match
or all matches was made through an addition argument to <code>replace</code>, or
by providing a different method <code>replaceAll</code>. But for some unfortunate
reason, the choice was made to rely on a property of the regular
expression instead.</p>
<p><a class=p_ident id="p_/5YU/Qo2Np" href="#p_/5YU/Qo2Np"></a>The real power of using regular expressions with <code>replace</code> comes from
the fact that we can refer back to the matched groups in the
replacement string. For example, say we have a big string containing
the names of people, one name per line, in the format <code>Lastname,
Firstname</code>. If we want to swap these names and remove the comma to get
a simple <code>Firstname Lastname</code> format, we can use the following code:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_rkgG8o9tWE" href="#c_rkgG8o9tWE"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(
  <span class="cm-string">"Hopper, Grace\nMcCarthy, John\nRitchie, Dennis"</span>
    .<span class="cm-property">replace</span>(<span class="cm-string-2">/([\w ]+), ([\w ]+)/g</span>, <span class="cm-string">"$2 $1"</span>));
<span class="cm-comment">// → Grace Hopper</span>
<span class="cm-comment">//   John McCarthy</span>
<span class="cm-comment">//   Dennis Ritchie</span></pre>
<p><a class=p_ident id="p_yMNsWvr4Lh" href="#p_yMNsWvr4Lh"></a>The <code>$1</code> and <code>$2</code> in the replacement string refer to the parenthesized
groups in the pattern. <code>$1</code> is replaced by the text that matched
against the first group, <code>$2</code> by the second, and so on, up to <code>$9</code>.
The whole match can be referred to with <code>$&amp;</code>.</p>
<p><a class=p_ident id="p_vI+NtinnDZ" href="#p_vI+NtinnDZ"></a>It is also possible to pass a function, rather than a string, as the
second argument to <code>replace</code>. For each replacement, the function will
be called with the matched groups (as well as the whole match) as
arguments, and the value it returns will be inserted into the new
string.</p>
<p><a class=p_ident id="p_3oXsRdfp6a" href="#p_3oXsRdfp6a"></a>Here&#8217;s a simple example:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Br7Xx39ol0" href="#c_Br7Xx39ol0"></a><span class="cm-keyword">var</span> <span class="cm-variable">s</span> <span class="cm-operator">=</span> <span class="cm-string">"the cia and fbi"</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">s</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\b(fbi|cia)\b/g</span>, <span class="cm-keyword">function</span>(<span class="cm-def">str</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">str</span>.<span class="cm-property">toUpperCase</span>();
}));
<span class="cm-comment">// → the CIA and FBI</span></pre>
<p><a class=p_ident id="p_EbMXoAagyr" href="#p_EbMXoAagyr"></a>And here&#8217;s a more interesting one:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_yP56zRm97Q" href="#c_yP56zRm97Q"></a><span class="cm-keyword">var</span> <span class="cm-variable">stock</span> <span class="cm-operator">=</span> <span class="cm-string">"1 lemon, 2 cabbages, and 101 eggs"</span>;
<span class="cm-keyword">function</span> <span class="cm-variable">minusOne</span>(<span class="cm-def">match</span>, <span class="cm-def">amount</span>, <span class="cm-def">unit</span>) {
  <span class="cm-variable-2">amount</span> <span class="cm-operator">=</span> <span class="cm-variable">Number</span>(<span class="cm-variable-2">amount</span>) <span class="cm-operator">-</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">amount</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) <span class="cm-comment">// only one left, remove the 's'</span>
    <span class="cm-variable-2">unit</span> <span class="cm-operator">=</span> <span class="cm-variable-2">unit</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">unit</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">amount</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>)
    <span class="cm-variable-2">amount</span> <span class="cm-operator">=</span> <span class="cm-string">"no"</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">amount</span> <span class="cm-operator">+</span> <span class="cm-string">" "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">unit</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stock</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/(\d+) (\w+)/g</span>, <span class="cm-variable">minusOne</span>));
<span class="cm-comment">// → no lemon, 1 cabbage, and 100 eggs</span></pre>
<p><a class=p_ident id="p_bv4e/DVilz" href="#p_bv4e/DVilz"></a>This takes a string, finds all occurrences of a number followed by an
alphanumeric word, and returns a string wherein every such occurrence
is decremented by one.</p>
<p><a class=p_ident id="p_pEPUrWK5UJ" href="#p_pEPUrWK5UJ"></a>The <code>(\d+)</code> group ends up as the <code>amount</code> argument to the function,
and the <code>(\w+)</code> group gets bound to <code>unit</code>. The function converts the
amount to a number—which always works, since it matched <code>\d+</code>—and
makes some adjustments in case there is only one or zero left.</p>
<h2 id="_greed">Greed</h2>
<p><a class=p_ident id="p_AleOLIvq7B" href="#p_AleOLIvq7B"></a>It isn&#8217;t hard to use <code>replace</code> to write a function that removes all
comments from a piece of JavaScript code. Here is the first attempt:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_zdj+sx4mis" href="#c_zdj+sx4mis"></a><span class="cm-keyword">function</span> <span class="cm-variable">stripComments</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\/\/.*|\/\*[^]*\*\//g</span>, <span class="cm-string">""</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"1 + /* 2 */3"</span>));
<span class="cm-comment">// → 1 + 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"x = 10;// ten!"</span>));
<span class="cm-comment">// → x = 10;</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"1 /* a */+/* b */ 1"</span>));
<span class="cm-comment">// → 1  1</span></pre>
<p><a class=p_ident id="p_+ioZv3AAon" href="#p_+ioZv3AAon"></a>The part before the <em>or</em> operator simply matches two slash characters
followed by any number of non-newline characters. The part for
multi-line comments is more involved. We use <code>[^]</code> (any character that
is not in this empty set of characters) as a way to match any
character. Block comments can continue on a new line, so we can&#8217;t use
a dot here.</p>
<p><a class=p_ident id="p_s9E9JYjAYp" href="#p_s9E9JYjAYp"></a>But the output of the last example appears to have gone wrong. Why?</p>
<p><a class=p_ident id="p_atS1ERkauC" href="#p_atS1ERkauC"></a>The <code>.*</code> part of the expression, as I described in the section on
backtracking, will first match as much as it can, and then, if that
causes the part of the pattern after it to fail, move back one match
at a time and try from there. In this case, we are first matching the
whole rest of the string, and then moving back from there. It will
find an occurrence of <code>*/</code> after going back four characters, and match
that. This is not what we wanted—the intention was to match a single
comment, not to go all the way to the end of the code and find the end
of the last block comment.</p>
<p><a class=p_ident id="p_KvYdXsuwxG" href="#p_KvYdXsuwxG"></a>There are two variants of the repetition operators (“+”, “<code>*</code>”, “?”,
and “{}”). By default, they are <em>greedy</em>, meaning they match as much
as they can and backtrack from there. If you put a question mark after
them, they become non-greedy, and start by matching as little as
possible, only matching more when the remaining pattern does not fit
with the smaller match.</p>
<p><a class=p_ident id="p_0L47KZXZKa" href="#p_0L47KZXZKa"></a>And that is exactly what we want in this case. By having the star
match the smallest stretch of characters that brings us to a “<code>*/</code>”
closing marker, we consume one block comment, and nothing more.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_0e+jWcCHlB" href="#c_0e+jWcCHlB"></a><span class="cm-keyword">function</span> <span class="cm-variable">stripComments</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\/\/.*|\/\*[^]*?\*\//g</span>, <span class="cm-string">""</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"1 /* a */+/* b */ 1"</span>));
<span class="cm-comment">// → 1 + 1</span></pre>
<h2 id="_dynamically_creating_regexp_objects">Dynamically creating RegExp objects</h2>
<p><a class=p_ident id="p_2A78iOXDCO" href="#p_2A78iOXDCO"></a>There are cases where you might not know the exact
pattern you need to match against when you are writing your code. Say
you want to look for the user&#8217;s name in a piece of text, and enclose
it in underscore characters to make it stand out. The name is only
known when the program is actually running, so we can not use the
slash-based notation.</p>
<p><a class=p_ident id="p_MY5j7Rz84i" href="#p_MY5j7Rz84i"></a>But we can build up a string and use the <code>RegExp</code> constructor on that.
For example:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Ev1eKzYhvk" href="#c_Ev1eKzYhvk"></a><span class="cm-keyword">var</span> <span class="cm-variable">name</span> <span class="cm-operator">=</span> <span class="cm-string">"harry"</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">text</span> <span class="cm-operator">=</span> <span class="cm-string">"Harry is a suspicious character."</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">regexp</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">"\\b("</span> <span class="cm-operator">+</span> <span class="cm-variable">name</span> <span class="cm-operator">+</span> <span class="cm-string">")\\b"</span>, <span class="cm-string">"gi"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-variable">regexp</span>, <span class="cm-string">"_$1_"</span>));
<span class="cm-comment">// → _Harry_ is a suspicious character.</span></pre>
<p><a class=p_ident id="p_HSSj6TRfsw" href="#p_HSSj6TRfsw"></a>When creating the <code>\b</code> boundary markers, we have to use two
backslashes, because we are writing them in a normal string, not a
slash-enclosed regular expression. The options (global and
case-insensitive) for the regular expression can be given as a second
argument to the <code>RegExp</code> constructor.</p>
<p><a class=p_ident id="p_W/atxcKoEp" href="#p_W/atxcKoEp"></a>But what if the name is <code>"dea+hl[]rd"</code> because our user is a nerdy
teenager? That would resulint in a nonsensical regular expression,
which won&#8217;t actually match the user&#8217;s name.</p>
<p><a class=p_ident id="p_0Mx4Lf/w4/" href="#p_0Mx4Lf/w4/"></a>To work around this, we can add backslashes before any character that
we don&#8217;t trust. Adding backslashes before alphabetic characters is a
bad idea, because things like <code>\b</code> and <code>\n</code> have a special meaning.
But escaping everything that&#8217;s not alphanumeric or whitespace is safe.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_3qouqvqwCb" href="#c_3qouqvqwCb"></a><span class="cm-keyword">var</span> <span class="cm-variable">name</span> <span class="cm-operator">=</span> <span class="cm-string">"dea+hl[]rd"</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">text</span> <span class="cm-operator">=</span> <span class="cm-string">"This dea+hl[]rd guy is super annoying."</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">escaped</span> <span class="cm-operator">=</span> <span class="cm-variable">name</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[^\w\s]/g</span>, <span class="cm-string">"\\$&amp;"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">regexp</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">"\\b("</span> <span class="cm-operator">+</span> <span class="cm-variable">escaped</span> <span class="cm-operator">+</span> <span class="cm-string">")\\b"</span>, <span class="cm-string">"gi"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-variable">regexp</span>, <span class="cm-string">"_$1_"</span>));
<span class="cm-comment">// → This _dea+hl[]rd_ guy is super annoying.</span></pre>
<h2 id="_the_search_method">The search method</h2>
<p><a class=p_ident id="p_7vPpkhqhrD" href="#p_7vPpkhqhrD"></a>The <code>indexOf</code> method on strings
can not be called with a regular expression. But there is another
method, <code>search</code>, which does expect a regular expression. Like
<code>indexOf</code>, it returns the first index on which the expression was
found, or -1 when it wasn&#8217;t found.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_YWkmdsq1UJ" href="#c_YWkmdsq1UJ"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"  word"</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"    "</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>));
<span class="cm-comment">// → -1</span></pre>
<p><a class=p_ident id="p_ac4zmLU6j7" href="#p_ac4zmLU6j7"></a>Unfortunately, there is no way to indicate that the match should start
at a given offset (as with the second argument to <code>indexOf</code>), which
would often be very useful.</p>
<h2 id="_the_lastindex_property">The lastIndex property</h2>
<p><a class=p_ident id="p_heIQ0/XXEu" href="#p_heIQ0/XXEu"></a>The <code>exec</code> method similarly does not provide a
convenient way to start searching from a given position in the string.
But it does provide an inconvenient way.</p>
<p><a class=p_ident id="p_F+JgzwxLtK" href="#p_F+JgzwxLtK"></a>Regular expression
objects have properties (such as <code>source</code>, which contains the string
that expression was created from). One such property, <code>lastIndex</code>,
controls, in some limited circumstances, where the next match will
start.</p>
<p><a class=p_ident id="p_y8GS9OJXkh" href="#p_y8GS9OJXkh"></a>Those circumstances are that the regular expression must have the
“global” (<code>g</code>) option enabled, and the match must happen through the
<code>exec</code> method. Again, the sane way would have been to just allow an
extra argument to be passed to <code>exec</code>, but sanity is not a defining
characteristic of JavaScript&#8217;s regular expression interface.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Wy75i+pob7" href="#c_Wy75i+pob7"></a><span class="cm-keyword">var</span> <span class="cm-variable">pattern</span> <span class="cm-operator">=</span> <span class="cm-string-2">/y/g</span>;
<span class="cm-variable">pattern</span>.<span class="cm-property">lastIndex</span> <span class="cm-operator">=</span> <span class="cm-number">3</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-variable">pattern</span>.<span class="cm-property">exec</span>(<span class="cm-string">"xyzzy"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → 4</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">pattern</span>.<span class="cm-property">lastIndex</span>);
<span class="cm-comment">// → 5</span></pre>
<p><a class=p_ident id="p_22P5vf07lF" href="#p_22P5vf07lF"></a>The <code>lastIndex</code> property is updated by the call to <code>exec</code> to point
after the match when the match was successful. When no match was
found, <code>lastIndex</code> is set back to zero, which is also the value it has
in a newly constructed regular expression object.</p>
<p><a class=p_ident id="p_042bNmzNZK" href="#p_042bNmzNZK"></a>When using a global regular expressions value for multiple <code>exec</code>
calls, this changing of the <code>lastIndex</code> property can cause
problems—your regular expression might be accidentally starting at an
index that was left over from a previous call.</p>
<p><a class=p_ident id="p_9l7tQ3SsME" href="#p_9l7tQ3SsME"></a>Another interesting effect of the global option is
that changes the way the <code>match</code> method on strings works. When called
with a global expression, instead of returning an array similar to
that returned by <code>exec</code>, <code>match</code> will find <em>all</em> matches of the
pattern in the string, and return an array containing the matched
strings.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Omc+QSkcb/" href="#c_Omc+QSkcb/"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Banana"</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/an/g</span>));
<span class="cm-comment">// → ["an", "an"]</span></pre>
<p><a class=p_ident id="p_zFHO63a2iV" href="#p_zFHO63a2iV"></a>So be cautious with global regular expressions. The cases where they
are necessary—calls to <code>replace</code> and places where you want to
explicitly use <code>lastIndex</code>—are typically the only places where you
want to use them.</p>
<p><a class=p_ident id="p_sFhvrUR1vm" href="#p_sFhvrUR1vm"></a>A common pattern is to scan through all occurrences of a pattern in a
string, with full access to matched groups and the <code>index</code> property,
by using <code>lastIndex</code> and <code>exec</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_G/dooaJZho" href="#c_G/dooaJZho"></a><span class="cm-keyword">var</span> <span class="cm-variable">input</span> <span class="cm-operator">=</span> <span class="cm-string">"A text with 3 numbers in it... 42 and 88."</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">number</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\b(\d+)\b/g</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">match</span>;
<span class="cm-keyword">while</span> (<span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-variable">number</span>.<span class="cm-property">exec</span>(<span class="cm-variable">input</span>))
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Found"</span>, <span class="cm-variable">match</span>[<span class="cm-number">1</span>], <span class="cm-string">"at"</span>, <span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → Found 3 at 12</span>
<span class="cm-comment">//   Found 42 at 31</span>
<span class="cm-comment">//   Found 88 at 38</span></pre>
<p><a class=p_ident id="p_ZdCI2+edqA" href="#p_ZdCI2+edqA"></a>This makes use of the fact that the value of an assignment expression
(“=”) is the assigned value. So by using <code>match = re.exec(input)</code> as
the condition in the <code>while</code> statement, we perform the match at the
start of each iteration, save its result in a variable, and stop
looping when it returns null because no more matches are found.</p>
<h2 id="_parsing_an_ini_file">Parsing an INI file</h2>
<p><a class=p_ident id="p_JbrLORqV9r" href="#p_JbrLORqV9r"></a>To conclude the chapter, we&#8217;ll look at a real problem
that calls for regular expressions. Imagine we are writing a program
to automatically harvest information about our enemies from the
Internet. (We will not actually write that program here, just the part
that reads the configuration file. Sorry to disappoint.) The
configuration file looks like this:</p>
<pre data-language="text/plain" class="snippet cm-s-default"><a class=c_ident id="c_+P8SOLac1c" href="#c_+P8SOLac1c"></a>searchengine=http://www.google.com/search?q=$1
spitefulness=9.7

; comments are preceded by a semicolon...
; these are sections, concerning individual enemies
[larry]
fullname=Larry Doe
type=kindergarten bully
website=http://www.geocities.com/CapeCanaveral/11451

[gargamel]
fullname=Gargamel
type=evil sorcerer
outputdir=/home/marijn/enemies/gargamel</pre>
<p><a class=p_ident id="p_OgIQS1TJxB" href="#p_OgIQS1TJxB"></a>The exact rules for this format (which is actually a
widely used format, usually called an <em>INI</em> file) are as follows:</p>
<div class="ulist"><ul>
<li>
<p>
Blank lines and lines starting with semicolons are ignored.
</p>
</li>
<li>
<p>
Lines wrapped in <code>[</code> and <code>]</code> start a new section.
</p>
</li>
<li>
<p>
Lines containing an alphanumeric identifier followed by an <code>=</code>
  character add a setting to the current section.
</p>
</li>
<li>
<p>
Anything else is invalid.
</p>
</li>
</ul></div>
<p><a class=p_ident id="p_LWCnDNCUFW" href="#p_LWCnDNCUFW"></a>Our task is to convert a string like this into an array of objects,
each with a <code>name</code> property and an array of <code>name</code>/<code>value</code> pairs.
We&#8217;ll need one such object for each section and one for the
section-less settings at the top.</p>
<p><a class=p_ident id="p_7Rhyv7/Fbp" href="#p_7Rhyv7/Fbp"></a>Since the format has to be processed line by line, splitting the file
up into separate lines is a good start. We&#8217;ve used the <code>split</code> method
once in Chapter 6, as <code>string.split("\n")</code>. Some operating systems,
however, use not just a newline character to separate lines but a
carriage return character followed by a newline (<code>"\r\n"</code>).</p>
<p><a class=p_ident id="p_S/gGiWEAlv" href="#p_S/gGiWEAlv"></a>Given that the <code>split</code> method also allows a regular expression as its
argument, we can split on a regular expression like <code>/\r?\n/</code> to split
in a way that allows both <code>"\n"</code> and <code>"\r\n"</code> between lines.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_DKD6TIJJRw" href="#c_DKD6TIJJRw"></a><span class="cm-keyword">function</span> <span class="cm-variable">parseINI</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">currentCategory</span> <span class="cm-operator">=</span> {<span class="cm-property">name</span>: <span class="cm-atom">null</span>, <span class="cm-property">fields</span>: []};
  <span class="cm-keyword">var</span> <span class="cm-def">categories</span> <span class="cm-operator">=</span> [<span class="cm-variable-2">currentCategory</span>];

  <span class="cm-variable-2">string</span>.<span class="cm-property">split</span>(<span class="cm-string-2">/\r?\n/</span>).<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">line</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">match</span>;
    <span class="cm-keyword">if</span> (<span class="cm-string-2">/^\s*(;.*)?$/</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">line</span>)) {
      <span class="cm-keyword">return</span>;
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/^\[(.*)\]$/</span>)) {
      <span class="cm-variable-2">currentCategory</span> <span class="cm-operator">=</span> {<span class="cm-property">name</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">1</span>], <span class="cm-property">fields</span>: []};
      <span class="cm-variable-2">categories</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">currentCategory</span>);
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/^(\w+)=(.*)$/</span>)) {
      <span class="cm-variable-2">currentCategory</span>.<span class="cm-property">fields</span>.<span class="cm-property">push</span>({<span class="cm-property">name</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">1</span>],
                                   <span class="cm-property">value</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">2</span>]});
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Line '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">line</span> <span class="cm-operator">+</span> <span class="cm-string">"' is invalid."</span>);
    }
  });

  <span class="cm-keyword">return</span> <span class="cm-variable-2">categories</span>;
}</pre>
<p><a class=p_ident id="p_kDkXIMnZzi" href="#p_kDkXIMnZzi"></a>The code goes over every line in the file. It keeps a “current
category” object, and when it finds a normal directive, it adds it to
this object. When it encounters a line that starts a new category, it
replaces the current category with a new one, to which subsequent
directives will get added. Finally, it returns an array containing all
the categories it came across.</p>
<p><a class=p_ident id="p_x1EZrxfhg0" href="#p_x1EZrxfhg0"></a>Note the recurring use of <code>^</code> and <code>$</code> to make sure the expression
matches the whole line, not just part of it. Leaving these out is a
common mistake, which results in code that mostly works but behaves
strangely for some input.</p>
<p><a class=p_ident id="p_6CEHsZEfuX" href="#p_6CEHsZEfuX"></a>The expression <code>/^\s*(;.*)?$/</code> can be used to test for lines that can
be ignored. Do you see how it works? The part between the parentheses
will match comments, and the <code>?</code> after that will make sure it also
matches lines with only whitespace.</p>
<p><a class=p_ident id="p_SLY/jPojdT" href="#p_SLY/jPojdT"></a>The pattern <code>if (match = string.match(...))</code> is similar to the trick
where I used an assignment as the condition for <code>while</code>. You usually
aren&#8217;t sure that your expression will match. But you only want to do
something with the resulting match array if it not null, so you need
to test for that first. To not break the pleasant chain of <code>if</code> forms,
we assign the result of the match to a variable as, and immediately
use that assignment as the test in the <code>if</code> statement.</p>
<h2 id="_international_characters">International characters</h2>
<p><a class=p_ident id="p_uppk4yToyM" href="#p_uppk4yToyM"></a>Due to an initial simplistic implementation, and the fact that this
simplistic approach was later set in stone as standard behavior,
JavaScript&#8217;s regular expressions are rather dumb about characters that
do not appear in the English language. For example a “word” character,
as far as JavaScript&#8217;s regular expressions are concerned, actually
means the 26 characters in the Latin alphabet, their upper-case
variants, and, for some reason, the underscore character. Things like
“é” or “β”, which most definitely are word characters, will not match
<code>\w</code> (and <em>will</em> match upper-case <code>\W</code>, the non-word category).</p>
<p><a class=p_ident id="p_J4Zin+UvFv" href="#p_J4Zin+UvFv"></a>Through strange historical accident, <code>\s</code> (whitespace) is different,
and will match all characters that the Unicode standard considers
whitespace, such as a non-breaking space or a Mongolian vowel
separator.</p>
<p><a class=p_ident id="p_ssmpiUydMx" href="#p_ssmpiUydMx"></a>Some regular expression implementations in other programming languages
have syntax to match specific Unicode character categories, such as
all uppercase letters, all punctuation, control characters, or
similar. There are plans to add support to this to JavaScript, but
they unfortunately look like they won&#8217;t be realized in the near
future.</p>
<h2 id="_summary">Summary</h2>
<p><a class=p_ident id="p_eb9yc7lDY8" href="#p_eb9yc7lDY8"></a>Regular expressions are objects that represent patterns in strings.
They use their own syntax for expressing these patterns.</p>
<table>
<tr>
<td><code>/abc/</code></td>
<td>Sequence of characters</td>
</tr>
<tr>
<td><code>/[abc]/</code></td>
<td>Any character from a set of characters</td>
</tr>
<tr>
<td><code>/[^abc]/</code></td>
<td>Any character <em>not</em> in a set of characters</td>
</tr>
<tr>
<td><code>/[0-9]/</code></td>
<td>Any character in a range of characters</td>
</tr>
<tr>
<td><code>/x+/</code></td>
<td>One or more occurrences of a pattern</td>
</tr>
<tr>
<td><code>/x+?/</code></td>
<td>One or more occurrences, non-greedy</td>
</tr>
<tr>
<td><code>/x*/</code></td>
<td>Zero or more occurrences</td>
</tr>
<tr>
<td><code>/x?/</code></td>
<td>Zero or one occurrence</td>
</tr>
<tr>
<td><code>/x{2,4}/</code></td>
<td>Between two and four occurrences</td>
</tr>
<tr>
<td><code>/(abc)+/</code></td>
<td>Grouping</td>
</tr>
<tr>
<td><code>/a|b|c/</code></td>
<td>Alternative patterns</td>
</tr>
<tr>
<td><code>/\d/</code></td>
<td>Digit characters</td>
</tr>
<tr>
<td><code>/\w/</code></td>
<td>Alphanumeric characters (“word characters”)</td>
</tr>
<tr>
<td><code>/\s/</code></td>
<td>Whitespace characters</td>
</tr>
<tr>
<td><code>/./</code></td>
<td>All characters except newlines</td>
</tr>
<tr>
<td><code>/\b/</code></td>
<td>Word boundary</td>
</tr>
<tr>
<td><code>/^/</code></td>
<td>Start of input</td>
</tr>
<tr>
<td><code>/$/</code></td>
<td>End of input</td>
</tr>
</table>
<p><a class=p_ident id="p_AVY5pFcEyH" href="#p_AVY5pFcEyH"></a>A regular expression has a method <code>test</code> to test whether a given
string matches it, and a method <code>exec</code> which, when a match is found,
returns an array containing all matched groups and an <code>index</code> property
that indicates where the match started.</p>
<p><a class=p_ident id="p_Ml7hKXO6Ll" href="#p_Ml7hKXO6Ll"></a>Strings have a <code>match</code> method to match them against a regular
expression, and a <code>search</code> method to search for one. Their <code>replace</code>
method can replace matches of a pattern with a replacement string.
Alternatively, you can pass a function to <code>replace</code>, which will be
used to build up a replacement string based on the match text and
matched groups.</p>
<p><a class=p_ident id="p_XsUkGFZG+B" href="#p_XsUkGFZG+B"></a>Regular expressions can have options (flags), which are written after
the closing slash. The “i” option makes the match case-insensitive,
and the “g” option makes the expression <em>global</em> which, among other
things, causes the <code>replace</code> method to replace all instances instead
of just the first.</p>
<p><a class=p_ident id="p_CW10Ac/SDj" href="#p_CW10Ac/SDj"></a>The <code>RegExp</code> constructor can be used to create a regular expression
value from a string.</p>
<p><a class=p_ident id="p_cLM04SsTM1" href="#p_cLM04SsTM1"></a>Regular expressions are a sharp tool with an awkward handle. They&#8217;ll
simplify some tasks tremendously, but quickly become unmanageable when
applied to complex problems. Part of knowing how to use them is
knowing when to give up on them and switch to a more explicit
approach.</p>
<h2 id="_exercises">Exercises</h2>
<p><a class=p_ident id="p_meNfX2B/+s" href="#p_meNfX2B/+s"></a>It is almost unavoidable that, in the course of working on these
exercises, you will be confused and frustrated by some regular
expression&#8217;s inexplicable behavior. Sometimes it helps to enter your
expression into an online tool like
<a href="https://www.debuggex.com/"><em>debuggex.com</em></a>, to see whether its
visualization corresponds to what you intended, and to experiment with
the way it responds to various input strings.</p>
<h3 id="_regex_golf">Regex golf</h3>
<p><a class=p_ident id="p_1t8xXpFN7O" href="#p_1t8xXpFN7O"></a>“Code golf” is a term used for the game of trying to express a
particular program in as few characters as possible. Similarly, regex
golf is the practice of writing as tiny a regular expression as
possible to match a given pattern (and only that pattern).</p>
<p><a class=p_ident id="p_1VF0lgvpgG" href="#p_1VF0lgvpgG"></a>Write regular expressions that tests whether any of the sub-strings
given occur in a string. The regular expression should match <em>only</em>
strings containing one the sub-strings described. Do not worry about
word boundaries unless explicitly mentioned. When your expression
works, see if you can make it any smaller.</p>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
“car” and “cat”
</p>
</li>
<li>
<p>
“pop” and “prop”
</p>
</li>
<li>
<p>
“ferret”, “ferry”, and “ferrari”
</p>
</li>
<li>
<p>
Any word <em>ending</em> in “ious”
</p>
</li>
<li>
<p>
A whitespace character followed by a dot, comma, colon, or semicolon
</p>
</li>
<li>
<p>
A word longer than 6 letters
</p>
</li>
<li>
<p>
A word without the letter “e”
</p>
</li>
</ol></div>
<p><a class=p_ident id="p_EPnyensmbg" href="#p_EPnyensmbg"></a>Refer back to the table in the chapter summary to quickly look
something up. Test each solution out with a few test strings.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_PjFdBrmWuQ" href="#c_PjFdBrmWuQ"></a><span class="cm-comment">// Fill in the regular expressions</span>

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"my car"</span>, <span class="cm-string">"bad cats"</span>],
       [<span class="cm-string">"camper"</span>, <span class="cm-string">"high art"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"pop culture"</span>, <span class="cm-string">"mad props"</span>],
       [<span class="cm-string">"plop"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"ferret"</span>, <span class="cm-string">"ferry"</span>, <span class="cm-string">"ferrari"</span>],
       [<span class="cm-string">"ferrum"</span>, <span class="cm-string">"transfer A"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"how delicious"</span>, <span class="cm-string">"spacious room"</span>],
       [<span class="cm-string">"ruinous"</span>, <span class="cm-string">"consciousness"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"bad punctuation ."</span>],
       [<span class="cm-string">"escape the dot"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"hottentottententen"</span>],
       [<span class="cm-string">"no"</span>, <span class="cm-string">"hotten totten tenten"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"red platypus"</span>, <span class="cm-string">"wobbling nest"</span>],
       [<span class="cm-string">"earth bed"</span>, <span class="cm-string">"learning ape"</span>]);


<span class="cm-keyword">function</span> <span class="cm-variable">verify</span>(<span class="cm-def">regexp</span>, <span class="cm-def">yes</span>, <span class="cm-def">no</span>) {
  <span class="cm-comment">// Ignore unfinished exercises</span>
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">regexp</span>.<span class="cm-property">source</span> <span class="cm-operator">==</span> <span class="cm-string">"..."</span>) <span class="cm-keyword">return</span>;
  <span class="cm-variable-2">yes</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">regexp</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Failure to match '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
  });
  <span class="cm-variable-2">no</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">regexp</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Unexpected match for '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
  });
}</pre>
<h3 id="_quoting_style">Quoting style</h3>
<p><a class=p_ident id="p_Zvl6rHT09m" href="#p_Zvl6rHT09m"></a>Imagine you have written a text, and used single quotation marks
throughout. Now you want to replace all those that actually quote a
piece of text with double quotes, but <strong>not</strong> the ones used in
contractions like “aren&#8217;t”.</p>
<p><a class=p_ident id="p_k3Y0NF9w4b" href="#p_k3Y0NF9w4b"></a>Think of a pattern that distinguishes these two kind of quote usage
and craft a call to the <code>replace</code> method that does the proper
replacement.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_KNcaojz4vQ" href="#c_KNcaojz4vQ"></a><span class="cm-keyword">var</span> <span class="cm-variable">text</span> <span class="cm-operator">=</span> <span class="cm-string">"'I'm the cook,' he said, 'it's my job.'"</span>;
<span class="cm-comment">// Change this call.</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/A/g</span>, <span class="cm-string">"B"</span>));
<span class="cm-comment">// → "I'm the cook," he said, "it's my job."</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_rNoBQVCfFp" href="#p_rNoBQVCfFp"></a>The most obvious solution is to only replace quotes with a non-word
character on at least one side. Something like <code>/\W'|'\W/</code>. But you
also have to take the start and end of the line into account.</p>
<p><a class=p_ident id="p_1SUsrUgWek" href="#p_1SUsrUgWek"></a>In addition you must ensure that the replacement also includes the
characters that were matched by the <code>\W</code> pattern, so that those are
not dropped. This can be done by wrapping them in parentheses, and
including their groups in the replacement string (<code>$1</code>, <code>$2</code>). Groups
that are not matched will be replaced by nothing.</p>
</div></div>
<h3 id="_numbers_again">Numbers again</h3>
<p><a class=p_ident id="p_7MiBHhK7lM" href="#p_7MiBHhK7lM"></a>Series of digits can be matched by the simple regular expression
<code>/\d+/</code>.</p>
<p><a class=p_ident id="p_4ILW7h/ou4" href="#p_4ILW7h/ou4"></a>Write an expression that matches (only) JavaScript-style numbers. That
means it must support an optional minus <em>or</em> plus sign in front of the
number, the decimal dot, and exponent notation—<code>5e-3</code> or <code>1E10</code>—with
again an optional sign in front of the exponent. Also note that it is
not necessary for there to be digits in front of or after the dot—<code>.5</code>
and <code>5.</code> are valid JavaScript numbers, but a lone dot <em>isn&#8217;t</em>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_svZIRqtX/7" href="#c_svZIRqtX/7"></a><span class="cm-comment">// Fill in this regular expression.</span>
<span class="cm-keyword">var</span> <span class="cm-variable">number</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^...$/</span>;

<span class="cm-comment">// Tests:</span>
[<span class="cm-string">"1"</span>, <span class="cm-string">"-1"</span>, <span class="cm-string">"+15"</span>, <span class="cm-string">"1.55"</span>, <span class="cm-string">".5"</span>, <span class="cm-string">"5."</span>, <span class="cm-string">"1.3e2"</span>, <span class="cm-string">"1E-4"</span>,
 <span class="cm-string">"1e+12"</span>].<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">number</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Failed to match '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
});
[<span class="cm-string">"1a"</span>, <span class="cm-string">"+-1"</span>, <span class="cm-string">"1.2.3"</span>, <span class="cm-string">"1+1"</span>, <span class="cm-string">"1e4.5"</span>, <span class="cm-string">".5."</span>, <span class="cm-string">"1f5"</span>,
 <span class="cm-string">"."</span>].<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">number</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Incorrectly accepted '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
});</pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_vkoPQ1fhR2" href="#p_vkoPQ1fhR2"></a>First, do not forget the backslash in front of the dot.</p>
<p><a class=p_ident id="p_ShOca+aF11" href="#p_ShOca+aF11"></a>Matching the optional sign in front of the number, as well as in front
of the exponent, can be done with <code>[+\-]?</code> or <code>(+|-|)</code> (plus, minus,
or nothing).</p>
<p><a class=p_ident id="p_z9QJjd6IxQ" href="#p_z9QJjd6IxQ"></a>The more complicated part of the exercise is probably the problem of
matching both <code>"5."</code> and <code>".5"</code> without also matching <code>"."</code>. For this,
a good solution is to use the “|” operator to separate the two cases—either one or more digits optionally followed by a dot and zero or
more digits, <em>or</em> a dot followed by one or more digits.</p>
<p><a class=p_ident id="p_XC+73LgOvD" href="#p_XC+73LgOvD"></a>Finally, to make the “e” case-insensitive, either add an “i” option to
the regular expression, or use <code>[eE]</code>.</p>
</div></div>
<nav>
  <a href="08_error.html" title="previous chapter">⬅</a>
  <a href="index.html" title="cover">⬆</a>
  <a href="10_modules.html" title="next chapter">➡</a>
</nav>
</article>
