<!doctype html>
<head>
  <meta charset="utf-8">
  <title>Handling Events :: Eloquent JavaScript</title>
  <link rel=stylesheet href="../node_modules/codemirror/lib/codemirror.css">
  <script src="../node_modules/codemirror/lib/codemirror.js"></script>
  <script src="../node_modules/codemirror/mode/javascript/javascript.js"></script>
  <script src="../node_modules/codemirror/mode/css/css.js"></script>
  <script src="../node_modules/codemirror/mode/xml/xml.js"></script>
  <script src="../node_modules/codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <script src="../node_modules/codemirror/addon/edit/matchbrackets.js"></script>
  <script src="../node_modules/acorn/acorn.js"></script>
  <script src="../node_modules/acorn/util/walk.js"></script>
  <link rel=stylesheet href="ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 14;</script>
</head>

<article>
<nav>
  <a href="13_dom.html" title="previous chapter">⬅</a>
  <a href="index.html" title="cover">⬆</a>
  <a href="15_game.html" title="next chapter">➡</a>
</nav>

<h1><div class=chap_num>Chapter 14</div>Handling Events</h1>
<blockquote>
<p><a class=p_ident id="p_9vGtY0kynX" href="#p_9vGtY0kynX"></a>You have power over your mind—not outside events. Realize this, and
you will find strength.</p>
 <footer>Marcus Aurelius, <cite>Meditations</cite></footer>
</blockquote>
<p><a class=p_ident id="p_IYGbcq+Pzi" href="#p_IYGbcq+Pzi"></a>Some of the things that a program works with, such as direct user
input, happen at unpredictable times, in an unpredictable order. This
requires a different approach to control than the one we have used so
far.</p>
<h2 id="_event_handlers">Event handlers</h2>
<p><a class=p_ident id="p_VRG28QKlzH" href="#p_VRG28QKlzH"></a>Imagine an interface where the only way to find out whether a button
is pressed is to read the current state of that button. In order to be
able to react to that button, you would have to constantly read the
button&#8217;s state, so that you&#8217;d catch it before it was released again.
It would be dangerous to perform other computations that took a while,
since you might miss a button press.</p>
<p><a class=p_ident id="p_gL+2BzAZqa" href="#p_gL+2BzAZqa"></a>That is how things were done on <em>very</em> primitive machines. A step up
would be for the hardware or the operating system to notice the button
press, and put it in a queue somewhere. Our program can then
periodically check whether something has appeared in this queue, and
react to what it finds there.</p>
<p><a class=p_ident id="p_llZbht+m+p" href="#p_llZbht+m+p"></a>Of course, it has to remember to look at the queue, and to do it
often, because any time elapsed between the button being pressed and
our program getting around to seeing if a new event came in will cause
the software to feel unresponsive. This approach is called <em>polling</em>.
Most programmers avoid it whenever possible.</p>
<p><a class=p_ident id="p_yR0Vf6qqc8" href="#p_yR0Vf6qqc8"></a>A better mechanism is for the underlying system to immediately give
our code a chance to react to events as they occur. Browsers do this,
by allowing us to register functions as <em>handlers</em> for specific
events.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_hIpLxWoTSw" href="#c_hIpLxWoTSw"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Click on this document to activate the handler.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You clicked!"</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_MOjheGCW5Y" href="#p_MOjheGCW5Y"></a>The <code>addEventListener</code> function registers its second argument to be
called whenever the event described by its first argument occurs.</p>
<h2 id="_events_and_dom_nodes">Events and DOM nodes</h2>
<p><a class=p_ident id="p_OFueY9yZeF" href="#p_OFueY9yZeF"></a>Each browser event handler is registered in a context. When you call
<code>addEventListener</code> as above, you are calling it as a method on the
whole window, because in the browser the global scope is equivalent to
the <code>window</code> object. Every DOM element has an <code>addEventListener</code> method,
which allows you to listen specifically on that element.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_rxKXweM7xy" href="#c_rxKXweM7xy"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>Click me<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>No handler here.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"button"</span>);
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Button clicked."</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_Z6nIboJD5T" href="#p_Z6nIboJD5T"></a>The example attaches a handler to the button node, and thus only
clicks on the button cause that handler to run.</p>
<p><a class=p_ident id="p_W7h55VLIOS" href="#p_W7h55VLIOS"></a>An <code>onclick</code> attribute put directly on a node has a similar effect.
But a node only has one <code>onclick</code> attribute, so you can only register
one handler per node that way. The <code>addEventListener</code> method allow any
number of handlers to be added, so that you won&#8217;t accidentally replace
a handler registered by some other code.</p>
<p><a class=p_ident id="p_4nY5BL0V8w" href="#p_4nY5BL0V8w"></a>The <code>removeEventListener</code> method, called with the same type of
arguments as <code>addEventListener</code> removes a handler again.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_6D5MnxL1WF" href="#c_6D5MnxL1WF"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>Act-once button<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"button"</span>);
  <span class="cm-keyword">function</span> <span class="cm-variable">once</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Done."</span>);
    <span class="cm-variable">button</span>.<span class="cm-property">removeEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-variable">once</span>);
  }
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-variable">once</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_bEThNPNqvk" href="#p_bEThNPNqvk"></a>In order to be able to unregister it, we had to give our handler
function a name (<code>once</code>), so that we can pass the same value to
<code>removeEventListener</code> that we passed to <code>addEventListener</code>.</p>
<h2 id="_event_objects">Event objects</h2>
<p><a class=p_ident id="p_Xc8vqGxobm" href="#p_Xc8vqGxobm"></a>Though we have ignored it in the examples above, event handler
functions are actually passed an argument, the event object. This
object gives us additional information about the event. For example,
if we want to know <em>which</em> mouse button was pressed, we can look at
this object&#8217;s <code>button</code> property.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_E2E3/ZpD5k" href="#c_E2E3/ZpD5k"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>Click me any way you want<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"button"</span>);
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">button</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Left button"</span>);
    <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">button</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Middle button"</span>);
    <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">button</span> <span class="cm-operator">==</span> <span class="cm-number">2</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Right button"</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_6Vk6va5Rnz" href="#p_6Vk6va5Rnz"></a>The information stored in an event object differs per type of event.
We&#8217;ll discuss various types further on in this chapter. The object&#8217;s
<code>type</code> property always holds a string identifying the event (for
example <code>"click"</code> or <code>"mousedown"</code>).</p>
<h2 id="_bubbling">Bubbling</h2>
<p><a class=p_ident id="p_AMEe+Oabfh" href="#p_AMEe+Oabfh"></a>Event handlers registered on nodes with children will also receive
events that happen in the children. If a button inside a paragraph is
clicked, event handlers on the paragraph will also receive the click
event.</p>
<p><a class=p_ident id="p_UBfEVzqY/E" href="#p_UBfEVzqY/E"></a>But if both the paragraph and the button have a handler, the more
specific handler—the one on the button—gets to go first. Conceptually,
the event <em>bubbles</em> outwards, from the node where it happened, to that
node&#8217;s parent node, and on up to the root of the document. And
finally, handlers registered on the whole window get a chance to
respond to the event.</p>
<p><a class=p_ident id="p_mgXPeV1qcP" href="#p_mgXPeV1qcP"></a>At any point, an event handler can call the <code>stopPropagation</code> method
on the event object to prevent handlers “further up” from receiving
the event. This can be useful when, for example, you have a button
inside another clickable element, and you don&#8217;t want clicks on the
button to also activate the outer element&#8217;s click behavior.</p>
<p><a class=p_ident id="p_bK/NljEgsz" href="#p_bK/NljEgsz"></a>The example below registers mousedown handler on both a button and the
paragraph around it. When clicked with the right mouse button, the
handler for the button calls <code>stopPropagation</code>, which will prevent the
handler on the paragraph from running. When the button is clicked with
another mouse button, both handlers will run.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_5OBuiIvtis" href="#c_5OBuiIvtis"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>A paragraph with a <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>button<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"p"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"button"</span>);
  <span class="cm-variable">para</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Handler for paragraph."</span>);
  });
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Handler for button."</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">button</span> <span class="cm-operator">==</span> <span class="cm-number">2</span>)
      <span class="cm-variable-2">event</span>.<span class="cm-property">stopPropagation</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_k9/ATyFbC/" href="#p_k9/ATyFbC/"></a>Event objects have a <code>target</code> property that refers to the node where
they originate. You can also use this to ensure that you are not
accidentally handling something that bubbled up from a node you do not
want to handle. It is also possible to use the <code>target</code> property to
cast a wide net for a specific type of event. For example, if you
have a node containing a long list of buttons and you want to handle
clicks on these buttons, it may be more inconvenient to register a
single click handler on the outer node, and have it figure out whether
a button was clicked, than to register individual handlers on all of
the buttons.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_G9+Ky5/HMo" href="#c_G9+Ky5/HMo"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>A<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>B<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>C<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">target</span>.<span class="cm-property">nodeName</span> <span class="cm-operator">==</span> <span class="cm-string">"BUTTON"</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Clicked"</span>, <span class="cm-variable-2">event</span>.<span class="cm-property">target</span>.<span class="cm-property">textContent</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<h2 id="_default_actions">Default actions</h2>
<p><a class=p_ident id="p_mNZd3hJWtB" href="#p_mNZd3hJWtB"></a>Many events have a default action associated with them by the browser.
If you click a link, you will be taken to the link&#8217;s target. If you
press the down arrow, the browser will scroll the page down. A right
click opens a context menu. And so on.</p>
<p><a class=p_ident id="p_QdllRyXgOw" href="#p_QdllRyXgOw"></a>For most types of events, the JavaScript event handlers are called
<em>before</em> the default behavior is performed. When the handler takes
care of handling the event, and does not want the normal behavior to
also happen, it can call the <code>preventDefault</code> method on the event
object.</p>
<p><a class=p_ident id="p_pq9uoTGI7x" href="#p_pq9uoTGI7x"></a>This can be used to implement your own keyboard shortcuts or context
menu. It can also be used to obnoxiously interfere with the behavior
that users expect. For example, here is a link that can not be
followed:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_1pTBJXiKlR" href="#c_1pTBJXiKlR"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">a</span> <span class="cm-attribute">href</span>=<span class="cm-string">"https://developer.mozilla.org/"</span><span class="cm-tag cm-bracket">></span>MDN<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">a</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">link</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"a"</span>);
  <span class="cm-variable">link</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Nope."</span>);
    <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_zsKv4JbFGn" href="#p_zsKv4JbFGn"></a>Try not to do such things unless you have a really good reason to. For
people using your page, it can be very unpleasant when expected
behavior is broken.</p>
<p><a class=p_ident id="p_KMgK6E70da" href="#p_KMgK6E70da"></a>Depending on the browser, some events can not be intercepted. On
Chrome, for example, keyboard shortcuts to close the current tab
(Control-W or Command-W) can not be handled by JavaScript.</p>
<h2 id="_key_events">Key events</h2>
<p><a class=p_ident id="p_LMd3daU6Qb" href="#p_LMd3daU6Qb"></a>When a key on the keyboard is pressed down, your browser fires a
<code>"keydown"</code> event. When it is released again, a <code>"keyup"</code> event is
fired.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class=c_ident id="c_+9Ni6GWlj0" href="#c_+9Ni6GWlj0"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>This page turns violet when you hold the V key.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keydown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span> <span class="cm-operator">==</span> <span class="cm-number">86</span>)
      <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">style</span>.<span class="cm-property">background</span> <span class="cm-operator">=</span> <span class="cm-string">"violet"</span>;
  });
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keyup"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span> <span class="cm-operator">==</span> <span class="cm-number">86</span>)
      <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">style</span>.<span class="cm-property">background</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>;
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_gQnz+6p78i" href="#p_gQnz+6p78i"></a>Despite its name, <code>"keydown"</code> is not only fired when the key is
physically pushed down. When a key is pressed and held, the event is
fired again every time the key <em>repeats</em>. Sometimes, for example when
you want to increase the acceleration of your game character when an
arrow key is pressed, and decrease it again when the key is released,
you have to be careful not to increase it again every time the key
repeats, or you&#8217;d end up with unintentionally huge values.</p>
<p><a class=p_ident id="p_aRFYh7xChP" href="#p_aRFYh7xChP"></a>The example above looked at the <code>keyCode</code> property of the event
object. This is the way we can identify which key is being pressed or
released. Unfortunately, it holds a number, and translating that
number to an actual key is not always obvious.</p>
<p><a class=p_ident id="p_y/Pr/lCtnH" href="#p_y/Pr/lCtnH"></a>For letter and number keys, the associated key code will be the
Unicode character code associated with the (upper case) letter printed
on the key. The <code>charCodeAt</code> method on strings gives us a way to find
this code:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_fxVTaBPpbk" href="#c_fxVTaBPpbk"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Violet"</span>.<span class="cm-property">charCodeAt</span>(<span class="cm-number">0</span>));
<span class="cm-comment">// → 86</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"1"</span>.<span class="cm-property">charCodeAt</span>(<span class="cm-number">0</span>));
<span class="cm-comment">// → 49</span></pre>
<p><a class=p_ident id="p_HVPFsxHIiv" href="#p_HVPFsxHIiv"></a>Other keys have less predictable key codes. The best way to find the
codes you need is usually by experiment—register a key event handler
that logs the key codes it gets, and press the key you are interested
in.</p>
<p><a class=p_ident id="p_8sidwZqwg7" href="#p_8sidwZqwg7"></a>Modifier keys like shift, control, alt, and meta (“command” on Mac)
generate key events just like normal keys. But when looking for key
combinations, you can also also find out whether these keys are held
down by looking at the <code>shiftKey</code>, <code>ctrlKey</code>, <code>altKey</code>, and <code>metaKey</code>
properties of keyboard (and mouse) events.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class=c_ident id="c_oVkiEW/tiK" href="#c_oVkiEW/tiK"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Press Control-Space to continue.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keydown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span> <span class="cm-operator">==</span> <span class="cm-number">32</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable-2">event</span>.<span class="cm-property">ctrlKey</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Continuing!"</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_p/+N5nU+rr" href="#p_p/+N5nU+rr"></a>The <code>"keydown"</code> and <code>"keyup"</code> events give you information about the
physical key that is being hit. When you are interested in text that
is being typed, deriving that from key codes is awkward. Instead,
there exists another event, <code>"keypress"</code>, for this purpose. It is
fired right after <code>"keydown"</code> (and repeated along with <code>"keydown"</code>
when the key is held), but only for keys that produce character input.
The <code>charCode</code> property in the event object contains a code that can
be interpreted as a Unicode character code. The <code>String.fromCharCode</code>
function can be used to turn this code into an actual
(single-character) string.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class=c_ident id="c_nQ9s0tO55l" href="#c_nQ9s0tO55l"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Focus this page and type something.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keypress"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">String</span>.<span class="cm-property">fromCharCode</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">charCode</span>));
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_EHGULml9MQ" href="#p_EHGULml9MQ"></a>The DOM node where key events originate depends on the element that is
currently focused. Normal nodes can not be focused (unless you give
them a <code>tabindex</code> attribute), but things like links, buttons, and form
fields can. We&#8217;ll come back to form fields in Chapter 18. When nothing
in particular is focused, <code>document.body</code> acts as the target node of
key events.</p>
<h2 id="_mouse_clicks">Mouse clicks</h2>
<p><a class=p_ident id="p_ksIyysOoPy" href="#p_ksIyysOoPy"></a>Clicking a mouse button also causes a number of events to be fired.
The <code>"mousedown"</code> and <code>"mouseup"</code> events are similar to <code>"keydown"</code>
and <code>"keyup"</code>, fired when the button is pressed and released. These
will happen on the DOM nodes that are immediately below the mouse
pointer when the event occurs.</p>
<p><a class=p_ident id="p_vxFLT2fw8e" href="#p_vxFLT2fw8e"></a>After the <code>"mouseup"</code> event, a <code>"click"</code> event is fired on the most
specific node that contained both the press and the release of the
button. For example, if I press down the mouse button on one
paragraph, and then move the pointer to another paragraph and release
the button, the <code>"click"</code> event will happen on the element that
contains both those paragraphs.</p>
<p><a class=p_ident id="p_gzmmLlVcMF" href="#p_gzmmLlVcMF"></a>If two clicks quickly follow each other, a <code>"dblclick"</code> (double click)
event is also fired, after the second click event.</p>
<p><a class=p_ident id="p_V3QuKrAk2Z" href="#p_V3QuKrAk2Z"></a>To get precise information about the place where a mouse event
happened, you can look at its <code>pageX</code> and <code>pageY</code> properties, which
contain the event&#8217;s coordinates (in pixels) relative to the top left
corner of the document.</p>
<p><a class=p_ident id="p_cLx0De+yva" href="#p_cLx0De+yva"></a>The following implements a primitive drawing program. Every time you
click on the document, it adds a dot under your mouse pointer.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_nplPzKchTA" href="#c_nplPzKchTA"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag">body</span> {
    <span class="cm-property">height</span>: <span class="cm-number">200px</span>;
    <span class="cm-property">background</span>: <span class="cm-keyword">beige</span>;
  }
  <span class="cm-qualifier">.dot</span> {
    <span class="cm-property">height</span>: <span class="cm-number">8px</span>; <span class="cm-property">width</span>: <span class="cm-number">8px</span>;
    <span class="cm-property">border-radius</span>: <span class="cm-number">4px</span>; <span class="cm-comment">/* rounds corners */</span>
    <span class="cm-property">background</span>: <span class="cm-keyword">blue</span>;
    <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">dot</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"div"</span>);
    <span class="cm-variable-2">dot</span>.<span class="cm-property">className</span> <span class="cm-operator">=</span> <span class="cm-string">"dot"</span>;
    <span class="cm-variable-2">dot</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span> <span class="cm-operator">-</span> <span class="cm-number">4</span>) <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">dot</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">pageY</span> <span class="cm-operator">-</span> <span class="cm-number">4</span>) <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">dot</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_DX6hKdqGfF" href="#p_DX6hKdqGfF"></a>The <code>clientX</code> and <code>clientY</code> properties are similar to <code>pageX</code> and
<code>pageY</code>, but relative to the part of the document that is currently
scrolled into view. These can be useful when comparing mouse
coordinates with the coordinates returned by <code>getBoundingClientRect</code>,
which yields the same type of coordinates.</p>
<h2 id="_mouse_motion">Mouse motion</h2>
<p><a class=p_ident id="p_Yjy/EtP24n" href="#p_Yjy/EtP24n"></a>Every time the mouse pointer moves, a <code>"mousemove"</code> event fires. This
event can be used to track the position of the mouse. A common
situation in which this is useful is when implementing some form of
mouse-dragging functionality.</p>
<p><a class=p_ident id="p_Z1h4BQYT0/" href="#p_Z1h4BQYT0/"></a>As an example, the program below displays a bar, and sets up
event handlers so that dragging to the left or right on this bar
makes it narrower or wider.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_XfG9fLfNl2" href="#c_XfG9fLfNl2"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Drag the bar to change its width:<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">style</span>=<span class="cm-string">"background: orange; width: 60px; height: 20px"</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">rect</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"div"</span>);
  <span class="cm-keyword">function</span> <span class="cm-variable">updateWidth</span>(<span class="cm-def">add</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">width</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-number">10</span>, <span class="cm-variable">rect</span>.<span class="cm-property">offsetWidth</span> <span class="cm-operator">+</span> <span class="cm-variable-2">add</span>);
    <span class="cm-variable">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">width</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
  }

  <span class="cm-keyword">var</span> <span class="cm-variable">dragging</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>, <span class="cm-variable">prevX</span>;
  <span class="cm-variable">rect</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">dragging</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
    <span class="cm-variable">prevX</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span>;
    <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>(); <span class="cm-comment">// Prevent selection</span>
  });
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mouseup"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">dragging</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
  });
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable">dragging</span>) {
      <span class="cm-variable">updateWidth</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span> <span class="cm-operator">-</span> <span class="cm-variable">prevX</span>);
      <span class="cm-variable">prevX</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span>;
    }
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_OkAFTS9SkH" href="#p_OkAFTS9SkH"></a>Note that the <code>"mouseup"</code> and <code>"mousemove"</code> handlers are registered on the
whole window. Even if the mouse goes outside of the bar during
resizing, we still want to update its size and stop dragging when the
mouse is released.</p>
<p><a class=p_ident id="p_6RVyVseCDj" href="#p_6RVyVseCDj"></a>Whenever the mouse pointer enters or leaves a node, the <code>"mouseover"</code>
or <code>"mouseout"</code> event is fired on this node. This can be used, among
other things, to create hover effects. But be careful, because these
events bubble just like other events, and thus you might
inconveniently receive a <code>"mouseout"</code> event for a node when the mouse
leaves one of its child nodes, which is not the point where you want
to turn off your hover effect.</p>
<p><a class=p_ident id="p_WkAAgbH7zo" href="#p_WkAAgbH7zo"></a>To work around it, we can use the <code>relatedTarget</code> property of the
event objects created for these events. It tells us, in the case of
<code>"mouseover"</code>, what element the pointer was over before, and in the
case of <code>"mouseout"</code>, what element it is going to. We only want to
change our hover effect when the <code>relatedTarget</code> is outside of our
target node. When that is the case, it means that this event actually
represents a <em>crossing over</em> from outside to inside the node (or the
other way around).</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_99Z6ak6eGX" href="#c_99Z6ak6eGX"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Hover over this <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">></span>paragraph<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">></span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"p"</span>);
  <span class="cm-keyword">function</span> <span class="cm-variable">isInside</span>(<span class="cm-def">node</span>, <span class="cm-def">target</span>) {
    <span class="cm-keyword">for</span> (; <span class="cm-variable-2">node</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>; <span class="cm-variable-2">node</span> <span class="cm-operator">=</span> <span class="cm-variable-2">node</span>.<span class="cm-property">parentNode</span>)
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">node</span> <span class="cm-operator">==</span> <span class="cm-variable-2">target</span>) <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
  }
  <span class="cm-variable">para</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mouseover"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">isInside</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">relatedTarget</span>, <span class="cm-variable">para</span>))
      <span class="cm-variable">para</span>.<span class="cm-property">style</span>.<span class="cm-property">color</span> <span class="cm-operator">=</span> <span class="cm-string">"red"</span>;
  });
  <span class="cm-variable">para</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mouseout"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">isInside</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">relatedTarget</span>, <span class="cm-variable">para</span>))
      <span class="cm-variable">para</span>.<span class="cm-property">style</span>.<span class="cm-property">color</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>;
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_QTE0dpHOFx" href="#p_QTE0dpHOFx"></a>The <code>isInside</code> function follows the given node&#8217;s parent links until it
either reaches the top of the document (when <code>node</code> becomes null), or
finds the parent we are looking for.</p>
<p><a class=p_ident id="p_UrlQHS95Sq" href="#p_UrlQHS95Sq"></a>I should add that the effect above can be much more easily achieved
using the CSS <em>pseudo-selector</em> <code>:hover</code>, as shown below. But when you
need to react to the mouse entering or leaving a node in a way that
does not just change some style, the technique shown above is needed.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_6w5/Alc/oe" href="#c_6w5/Alc/oe"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag">p</span>:<span class="cm-variable-3">hover</span> { <span class="cm-property">color</span>: <span class="cm-keyword">red</span> }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Hover over this <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">></span>paragraph<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">></span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span></pre>
<h2 id="_scroll_events">Scroll events</h2>
<p><a class=p_ident id="p_AbBLILzznY" href="#p_AbBLILzznY"></a>Whenever an element is scrolled, a <code>"scroll"</code> event is fired on it.
This has various uses, such as knowing what the user is currently
looking at (either to disable off-screen animation or to send secret
spy reports to your evil headquarters), or showing some indication of
progress (by highlighting a part of a document overview, or showing a
page or slide number).</p>
<p><a class=p_ident id="p_aKCDFJAMOy" href="#p_aKCDFJAMOy"></a>The example below draws a progress bar in the top right corner of the
document, and updates it to fill up as you scroll down.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_eYgQSRoPzX" href="#c_eYgQSRoPzX"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-qualifier">.progress</span> {
    <span class="cm-property">border</span>: <span class="cm-number">1px</span> <span class="cm-atom">solid</span> <span class="cm-keyword">blue</span>;
    <span class="cm-property">width</span>: <span class="cm-number">100px</span>;
    <span class="cm-property">position</span>: <span class="cm-atom">fixed</span>;
    <span class="cm-property">top</span>: <span class="cm-number">10px</span>; <span class="cm-property">right</span>: <span class="cm-number">10px</span>;
  }
  <span class="cm-qualifier">.progress</span> > <span class="cm-tag">div</span> {
    <span class="cm-property">height</span>: <span class="cm-number">12px</span>;
    <span class="cm-property">background</span>: <span class="cm-keyword">blue</span>;
    <span class="cm-property">width</span>: <span class="cm-number">0%</span>;
  }
  <span class="cm-tag">body</span> {
    <span class="cm-property">height</span>: <span class="cm-number">2000px</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">class</span>=<span class="cm-string">"progress"</span><span class="cm-tag cm-bracket">>&lt;</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Scroll me...<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">bar</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">".progress div"</span>);
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"scroll"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">max</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">scrollHeight</span> <span class="cm-operator">-</span> <span class="cm-variable">innerHeight</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">percent</span> <span class="cm-operator">=</span> (<span class="cm-variable">pageYOffset</span> <span class="cm-operator">/</span> <span class="cm-variable-2">max</span>) <span class="cm-operator">*</span> <span class="cm-number">100</span>;
    <span class="cm-variable">bar</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">percent</span> <span class="cm-operator">+</span> <span class="cm-string">"%"</span>;
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_J92IjzNbC5" href="#p_J92IjzNbC5"></a>Giving an element a <code>position</code> of <code>fixed</code> acts much like an <code>absolute</code>
position, but also prevents it from scrolling along with the rest of
the document. This is used to make our progress bar stay in its
corner. Inside of it is another element, which is resized to indicate
the current progress. We use <code>%</code>, rather than <code>px</code> as a unit when
setting the width, so that the element is sized relative to the whole
bar.</p>
<p><a class=p_ident id="p_H669XZxGuY" href="#p_H669XZxGuY"></a>The global <code>innerHeight</code> variable gives us the height of the window,
which we have to subtract from the total scrollable height, because
you can&#8217;t scroll down anymore when the bottom of the screen has
reached the bottom of the document. (There is, of course, also
<code>innerWidth</code>.) By dividing <code>pageYOffset</code> (the current scroll position)
by the maximum scroll position, and multiplying that by a hundred, we
get the percentage that we want to display.</p>
<p><a class=p_ident id="p_1GNavFugB6" href="#p_1GNavFugB6"></a>Calling <code>preventDefault</code> on a scroll event does not prevent the
scrolling from happening. In fact, the event handler is only called
<em>after</em> the scrolling took place.</p>
<h2 id="_focus_events">Focus events</h2>
<p><a class=p_ident id="p_r6SF152VBY" href="#p_r6SF152VBY"></a>When an element is focused, the browser fires a <code>"focus"</code> event on it.
When it loses focus, a <code>"blur"</code> event fires.</p>
<p><a class=p_ident id="p_Jwh2C2enPU" href="#p_Jwh2C2enPU"></a>Unlike to the events discussed earlier, these two events do not
<em>bubble</em>. A handler on a parent element is not notified when a child
element is focused or unfocused.</p>
<p><a class=p_ident id="p_ZEig0BrfsG" href="#p_ZEig0BrfsG"></a>The example below displays a help text for the text field that is
currently focused.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_QauJIo6Fii" href="#c_QauJIo6Fii"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Name: <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span> <span class="cm-attribute">type</span>=<span class="cm-string">"text"</span> <span class="cm-attribute">data-help</span>=<span class="cm-string">"Your full name"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Age: <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span> <span class="cm-attribute">type</span>=<span class="cm-string">"text"</span> <span class="cm-attribute">data-help</span>=<span class="cm-string">"Age in years"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">id</span>=<span class="cm-string">"help"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">help</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"#help"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">fields</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelectorAll</span>(<span class="cm-string">"input"</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">fields</span>.<span class="cm-property">length</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
    <span class="cm-variable">fields</span>[<span class="cm-variable">i</span>].<span class="cm-property">addEventListener</span>(<span class="cm-string">"focus"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">target</span>.<span class="cm-property">getAttribute</span>(<span class="cm-string">"data-help"</span>);
      <span class="cm-variable">help</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span> <span class="cm-variable-2">text</span>;
    });
    <span class="cm-variable">fields</span>[<span class="cm-variable">i</span>].<span class="cm-property">addEventListener</span>(<span class="cm-string">"blur"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
      <span class="cm-variable">help</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>;
    });
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_5HyY0t9dpU" href="#p_5HyY0t9dpU"></a>The window object will receive <code>"focus"</code> and <code>"blur"</code> events when the
user moves from or to the tab or window in which the document is
shown.</p>
<h2 id="_load_event">Load event</h2>
<p><a class=p_ident id="p_TDz51YDiwj" href="#p_TDz51YDiwj"></a>When page finishes loading, the <code>"load"</code> event is fired on the window
and the body. This is often used to schedule actions that initialize
something, but require the whole document to have been built up.
Remember that the content of <code>&lt;script&gt;</code> tags is run immediately, when
the tag is encountered. This is often too soon, for example when the
script needs to do something with parts of the document that appear
after the <code>&lt;script&gt;</code> tag.</p>
<p><a class=p_ident id="p_8mQQSD1RbE" href="#p_8mQQSD1RbE"></a>Elements like images and script tags that load an external file also
have a <code>"load"</code> event that indicates the files they reference were
loaded. Like the focus-related events, loading events do not bubble.</p>
<p><a class=p_ident id="p_nu8/BUQa7r" href="#p_nu8/BUQa7r"></a>When a page is closed or navigated away from (for example by following
a link), a <code>"beforeunload"</code> event is fired. The main use of this event
is to prevent the user from accidentally losing work by closing a
document. Doing this is not, as you might expect, done with the
<code>preventDefault</code> method. Instead, it is done by returning a string
from the handler. The string will be used in a dialog that asks the
user if they want to stay on the page or leave it. This mechanism
ensures that a user is able to leave the page, even if it running a
malicious script that would prefer to keep them there forever, in
order to force them to look at dodgy weight loss ads.</p>
<h2 id="_script_execution_timeline">Script execution timeline</h2>
<p><a class=p_ident id="p_m898wVhAww" href="#p_m898wVhAww"></a>There are various things that can cause a script to start executing.
Reading a <code>&lt;script&gt;</code> tag is obviously one such thing. An event firing,
if that even has a handler, is another. Chapter 13 discussed the
<code>requestAnimationFrame</code> function, which schedules a function to be
called before the next page redraw. That is yet another way in which a
script can start running.</p>
<p><a class=p_ident id="p_3Ya6RuV22D" href="#p_3Ya6RuV22D"></a>It is important to understand that, even though events can fire at any
time, no two scripts in a single document ever run at the same moment.
If a script is already running, event handlers and pieces of program
scheduled in other ways have to wait for their turn. This is also the
reason why a document will freeze when a script runs for a long time.
The browser can not react to clicks and other events inside the
document, because it can not run event handlers until the current
script finishes running.</p>
<p><a class=p_ident id="p_qOcAjNuS8p" href="#p_qOcAjNuS8p"></a>Some programming environments do allow multiple <em>threads of execution</em>
to run at the same time. Doing multiple things at the same time can be
used to make a program faster. But when you have multiple actors
touching the same parts of the system at the same time, thinking about
a program becomes at least an order of magnitude harder.</p>
<p><a class=p_ident id="p_omeCxjcdIQ" href="#p_omeCxjcdIQ"></a>The fact that JavaScript programs only do one thing at a time thus
makes our life easier. For cases where you <em>really</em> do want to do some
time-consuming thing in the background, without freezing the document,
browsers provide something called <em>Web Workers</em>. A worker is an
isolated JavaScript environment, which runs alongside the main program
for a document, and can only communicate with it by sending and
receiving messages.</p>
<p><a class=p_ident id="p_va4FyyRbox" href="#p_va4FyyRbox"></a>Assume we have this code in <code>js/squareworker.js</code>, which is a program
that computes squares, which we will run inside of an isolated worker
process.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_W+YwrW4zDz" href="#c_W+YwrW4zDz"></a><span class="cm-variable">addEventListener</span>(<span class="cm-string">"message"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
  <span class="cm-variable">postMessage</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">data</span> <span class="cm-operator">*</span> <span class="cm-variable-2">event</span>.<span class="cm-property">data</span>);
});</pre>
<p><a class=p_ident id="p_3bETV2ub20" href="#p_3bETV2ub20"></a>Imagine that squaring a number is a heavy, long-running computation
that we want to perform in a background thread. This code spawns a
worker, sends it a few messages, and outputs the responses.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_4tluabpFzc" href="#c_4tluabpFzc"></a><span class="cm-keyword">var</span> <span class="cm-variable">squareWorker</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Worker</span>(<span class="cm-string">"js/squareworker.js"</span>);
<span class="cm-variable">squareWorker</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"message"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"The worker responded:"</span>, <span class="cm-variable-2">event</span>.<span class="cm-property">data</span>);
});
<span class="cm-variable">squareWorker</span>.<span class="cm-property">postMessage</span>(<span class="cm-number">10</span>);
<span class="cm-variable">squareWorker</span>.<span class="cm-property">postMessage</span>(<span class="cm-number">24</span>);</pre>
<p><a class=p_ident id="p_Stp8nkaZHV" href="#p_Stp8nkaZHV"></a>The <code>postMessage</code> function sends a message, which will cause a
<code>"message"</code> event to fire in the receiver. The script that created the
worker sends and receives messages through the <code>Worker</code> object,
whereas the worker talks to the script that created it by sending and
listening directly on its global scope—which is a <em>new</em> global scope,
not shared with the original script.</p>
<h2 id="_setting_timers">Setting timers</h2>
<p><a class=p_ident id="p_5YmF46Q06c" href="#p_5YmF46Q06c"></a>The <code>setTimeout</code> function is similar to <code>requestAnimationFrame</code>. It
schedules another function to be called later. But instead of having
it called at the next redraw, it is given an amount of milliseconds to
wait before calling the function. This page turns from blue to yellow
after two seconds:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_+XGE0F3l+g" href="#c_+XGE0F3l+g"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">style</span>.<span class="cm-property">background</span> <span class="cm-operator">=</span> <span class="cm-string">"blue"</span>;
  <span class="cm-variable">setTimeout</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">style</span>.<span class="cm-property">background</span> <span class="cm-operator">=</span> <span class="cm-string">"yellow"</span>;
  }, <span class="cm-number">2000</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_de3VjAL+lV" href="#p_de3VjAL+lV"></a>Sometimes you need to cancel a function you have scheduled. This is
done by storing the value returned by <code>setTimeout</code>, and calling
<code>clearTimeout</code> on it.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_gue/8WsZbj" href="#c_gue/8WsZbj"></a><span class="cm-keyword">var</span> <span class="cm-variable">bombTimer</span> <span class="cm-operator">=</span> <span class="cm-variable">setTimeout</span>(<span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"BOOM!"</span>);
}, <span class="cm-number">500</span>);

<span class="cm-keyword">if</span> (<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">&lt;</span> <span class="cm-number">.5</span>) { <span class="cm-comment">// 50% chance</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Defused."</span>);
  <span class="cm-variable">clearTimeout</span>(<span class="cm-variable">bombTimer</span>);
}</pre>
<p><a class=p_ident id="p_c/F+71/NPg" href="#p_c/F+71/NPg"></a>The <code>cancelAnimationFrame</code> function works in the same way as
<code>clearTimeout</code>—calling it on a value returned by
<code>requestAnimationFrame</code> will cancel that frame (assuming it hasn&#8217;t
already been called).</p>
<p><a class=p_ident id="p_MTqUUpmFIN" href="#p_MTqUUpmFIN"></a>A similar set of functions, <code>setInterval</code> and <code>clearInterval</code> are used
to set timers that should repeat every X milliseconds.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_woAViW3Ypf" href="#c_woAViW3Ypf"></a><span class="cm-keyword">var</span> <span class="cm-variable">ticks</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">clock</span> <span class="cm-operator">=</span> <span class="cm-variable">setInterval</span>(<span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"tick"</span>, <span class="cm-variable">ticks</span><span class="cm-operator">++</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable">ticks</span> <span class="cm-operator">==</span> <span class="cm-number">10</span>) {
    <span class="cm-variable">clearInterval</span>(<span class="cm-variable">clock</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"stop."</span>);
  }
}, <span class="cm-number">200</span>);</pre>
<h2 id="_debouncing">Debouncing</h2>
<p><a class=p_ident id="p_I3Osg2AlyQ" href="#p_I3Osg2AlyQ"></a>Some types of events have the potential to fire rapidly, many times in
a row. The <code>"mousemove"</code> and <code>"scroll"</code> events, for example. When
handling such events, you must be careful not to do anything too
time-consuming, or your handler will take up so much time that
interaction with the document starts to feel slow and choppy.</p>
<p><a class=p_ident id="p_CvRYtJPZwz" href="#p_CvRYtJPZwz"></a>If you do need to do something non-trivial in such a handler, you can
use <code>setTimeout</code> to make sure you are not doing it too often. This is
usually called <em>debouncing</em> the event. There are several slightly
different approaches to this.</p>
<p><a class=p_ident id="p_LjD2e57wlj" href="#p_LjD2e57wlj"></a>In this first example, we want to do something when the user has typed
something, but we don&#8217;t want to do it immediately for every key event.
When they are typing quickly, we just want to wait until a pause
occurs. This is done by not immediately performing an action in the
event handler, but setting a timeout instead. We also clear the
previous timeout (if any), so that when events occur close together
(closer than our timeout delay), the timeout from the previous event
will be canceled.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_jyZKqfU0p3" href="#c_jyZKqfU0p3"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">textarea</span><span class="cm-tag cm-bracket">></span>Type something here...<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">textarea</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">textarea</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"textarea"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">timeout</span>;
  <span class="cm-variable">textarea</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"keydown"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">clearTimeout</span>(<span class="cm-variable">timeout</span>);
    <span class="cm-variable">timeout</span> <span class="cm-operator">=</span> <span class="cm-variable">setTimeout</span>(<span class="cm-keyword">function</span>() {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You stopped typing."</span>);
    }, <span class="cm-number">500</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_55az3iLtsc" href="#p_55az3iLtsc"></a>Giving an undefined value to <code>clearTimeout</code> or calling it on a timeout
that already fired has no effect. Thus, we don&#8217;t have to be careful
about when to call it, and simply do so for every event.</p>
<p><a class=p_ident id="p_866ynl3Km5" href="#p_866ynl3Km5"></a>A slightly different pattern occurs when we want to space responses to
an event at least a certain amount of time apart, but do want to fire
them <em>during</em> a series of events, not just afterwards. For example, we
want to respond to <code>"mousemove"</code> events by showing the current
coordinates of the mouse, but only every 250 milliseconds.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_Drd4JiWvgN" href="#c_Drd4JiWvgN"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">pending</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">pending</span>) {
      <span class="cm-variable">pending</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
      <span class="cm-variable">setTimeout</span>(<span class="cm-keyword">function</span>() {
        <span class="cm-variable">pending</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
        <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span>
          <span class="cm-string">"Mouse at "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span> <span class="cm-operator">+</span> <span class="cm-string">", "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">event</span>.<span class="cm-property">pageY</span>;
      }, <span class="cm-number">250</span>);
    }
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<h2 id="_summary">Summary</h2>
<p><a class=p_ident id="p_bKLVanKSm7" href="#p_bKLVanKSm7"></a>Event handlers make it possible to detect and react to events we have
no direct control over. The <code>addEventHandler</code> method is used to
register such a handler.</p>
<p><a class=p_ident id="p_pT/A7mXxlh" href="#p_pT/A7mXxlh"></a>Each event has a name (<code>"keydown"</code>, <code>"focus"</code>, etc.) that identifies
it. Most events are called on a specific DOM elements, and then
<em>bubble</em> up, allowing handlers associated with the parents of that
element to handle them.</p>
<p><a class=p_ident id="p_jK5bk5CuMw" href="#p_jK5bk5CuMw"></a>When an event handler is called, it is passed an event object, with
additional information about the event. This object also has methods
that allow us to prevent further bubbling (<code>stopPropagation</code>) and the
browser&#8217;s default handling of the event (<code>preventDefault</code>).</p>
<p><a class=p_ident id="p_8R4tiRRH3a" href="#p_8R4tiRRH3a"></a>Pressing a key fires <code>"keydown"</code>, <code>"keypress"</code>, and <code>"keyup"</code> events.
Pressing a mouse button fires <code>"mousedown"</code>, <code>"mouseup"</code>, and
<code>"click"</code> events. Moving the mouse fires <code>"mousemove"</code> and possible
<code>"mouseenter"</code> and <code>"mouseout"</code> events.</p>
<p><a class=p_ident id="p_zwo0vgzm7O" href="#p_zwo0vgzm7O"></a>Scrolling can be detected with the <code>"scroll"</code> event, and focus changes
with the <code>"focus"</code> and <code>"blur"</code> events. When the document finishes
loading, a <code>"load"</code> event fires on the window.</p>
<p><a class=p_ident id="p_0zJSMPD1MF" href="#p_0zJSMPD1MF"></a>Only one piece of JavaScript program can run at a time. Thus, event
handlers and other scheduled scripts have to wait until other scripts
finish, before they get their turn.</p>
<h2 id="_excercises">Excercises</h2>
<h3 id="_censored_keyboard">Censored keyboard</h3>
<p><a class=p_ident id="p_A36iaptk+x" href="#p_A36iaptk+x"></a>Between 1928 and 2013, Turkish law forbade the use of the letters “Q”,
“W”, and “X” in official documents. This was part of a wider
initiative to stifle Kurdish culture—those letters occur in the
language used by Kurdish people, but not in regular Turkish.</p>
<p><a class=p_ident id="p_JViXjbABER" href="#p_JViXjbABER"></a>As an exercise in doing ridiculous things with technology, I want to
ask you to program a text field (an <code>&lt;input type="text"&gt;</code> tag) in such
a way that these letters can not be typed into it.</p>
<p><a class=p_ident id="p_cs0DibmEsI" href="#p_cs0DibmEsI"></a>(Do not worry about copy-paste and other such loopholes.)</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_NDWTmM4UPL" href="#c_NDWTmM4UPL"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span> <span class="cm-attribute">type</span>=<span class="cm-string">"text"</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">field</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"input"</span>);
  <span class="cm-comment">// Your code here.</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_YBoRLaAVI/" href="#p_YBoRLaAVI/"></a>The solution to this exercise involves preventing the default behavior
of key events. You can handle either <code>"keypress"</code> (the most obvious)
or <code>"keydown"</code>. If either of them has <code>preventDefault</code> called on it,
the letter will not appear.</p>
<p><a class=p_ident id="p_/Pq3qIWZcN" href="#p_/Pq3qIWZcN"></a>Identifying the letter typed requires looking at the <code>keyCode</code> or
<code>charCode</code> property, and comparing that with the codes for the letters
we want to filter. In <code>"keydown"</code>, you do not have to worry about
lower- and upper-case letters, since it only identifies the key
pressed. If you decided to handle <code>"keypress"</code> instead, which
identifies actual characters typed, you have to make sure you test
both for both cases. One way to do that would be this:</p>
<pre>/[qwx]/i.test(String.fromCharCode(event.charCode))</pre>
</div></div>
<h3 id="_mouse_trail">Mouse trail</h3>
<p><a class=p_ident id="p_j4+NSbR+hs" href="#p_j4+NSbR+hs"></a>In JavaScript&#8217;s early days, which was the high time of gaudy
homepages with lots of animated images, people came up with some truly
inspiring ways to use the language.</p>
<p><a class=p_ident id="p_ZseDCwl6/C" href="#p_ZseDCwl6/C"></a>One of these was the “mouse trail”—a series of images following the
mouse as you moved it across the page.</p>
<p><a class=p_ident id="p_VJnHXjQGyq" href="#p_VJnHXjQGyq"></a>In this exercise, I want you to implement a mouse trail. Use
absolutely positioned <code>&lt;div&gt;</code> elements with a fixed size and
background color (refer back to the <a href="#c_nplPzKchTA">code</a> in the
section on mouse click events for an example). Create twelve such
elements, and when the mouse moves, display them in the wake of the
mouse pointer, somehow.</p>
<p><a class=p_ident id="p_/TVw+tEr/x" href="#p_/TVw+tEr/x"></a>There are various possible approaches here. You can make your solution
as complex as you want. To start with, a simple solution is to keep a
counter variable to cycle through your trail elements. Listen to
<code>"mousemove"</code> events, and every time one is fired, move the next
element to the point where the cursor currently is.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_p/xcQzljKg" href="#c_p/xcQzljKg"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-qualifier">.trail</span> { <span class="cm-comment">/* className for the trail elements */</span>
    <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>;
    <span class="cm-property">height</span>: <span class="cm-number">6px</span>; <span class="cm-property">width</span>: <span class="cm-number">6px</span>;
    <span class="cm-property">border-radius</span>: <span class="cm-number">3px</span>;
    <span class="cm-property">background</span>: <span class="cm-keyword">teal</span>;
  }
  <span class="cm-tag">body</span> {
    <span class="cm-property">height</span>: <span class="cm-number">300px</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-comment">// Your code here.</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_JMiSkEOEr3" href="#p_JMiSkEOEr3"></a>Creating the elements is best done in a loop. Append them to the
document to make them show up. In order to be able to access them
later, to change their position, store the trail elements in an array.</p>
<p><a class=p_ident id="p_seJm6U8e4t" href="#p_seJm6U8e4t"></a>Cycling through them can be done by keeping a counter variable, and
adding one to it every time the <code>"mousemove"</code> event fires. The
remainder operator (<code>% 10</code>) can then be used to get a valid array
index, to pick the element we want to position during a given event.</p>
<p><a class=p_ident id="p_cJRZn+Vuv9" href="#p_cJRZn+Vuv9"></a>Another interesting effect can be gotten by modeling a simple physics
system. The <code>"mousemove"</code> event is then used only to update a pair of
variables that track the mouse position. The animation is created by
using <code>requestAnimationFrame</code> to simulate the trailing elements being
attracted by the position of the mouse pointer. Every animation step,
their position is updated based on their relative position to the
pointer (and optionally, a speed that is stored for each element).
Figuring out a good way to do this is up to you.</p>
</div></div>
<h3 id="_tabs">Tabs</h3>
<p><a class=p_ident id="p_Ktj5JZEPdu" href="#p_Ktj5JZEPdu"></a>A tabbed interface is a commonly used pattern. It allows you to select
from a number of views by selecting little clips “sticking out” above
an element.</p>
<p><a class=p_ident id="p_rh5X8kUE8g" href="#p_rh5X8kUE8g"></a>In this exercise we implement a crude tab interface. Write a function
<code>asTabs</code> that, given a DOM node, creates a tabbed interface showing
the children of that node. It should insert a list of <code>&lt;button&gt;</code>
elements at the top of the node, one for each child node, containing
text retrieved from the <code>data-tabname</code> attributes of the child node.
All but one of the original children should be hidden (given a
<code>display</code> style of <code>none</code>), and the currently visible node can be
selected by clicking the buttons.</p>
<p><a class=p_ident id="p_744xb2mKFr" href="#p_744xb2mKFr"></a>When it works, extend it to also style the currently active button
differently.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_pC6tDMjD/o" href="#c_pC6tDMjD/o"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">id</span>=<span class="cm-string">"wrapper"</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">data-tabname</span>=<span class="cm-string">"one"</span><span class="cm-tag cm-bracket">></span>Tab one<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">data-tabname</span>=<span class="cm-string">"two"</span><span class="cm-tag cm-bracket">></span>Tab two<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">data-tabname</span>=<span class="cm-string">"three"</span><span class="cm-tag cm-bracket">></span>Tab three<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">function</span> <span class="cm-variable">asTabs</span>(<span class="cm-def">node</span>) {
    <span class="cm-comment">// Your code here.</span>
  }
  <span class="cm-variable">asTabs</span>(<span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"#wrapper"</span>));
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_Y9FsMe+LUL" href="#p_Y9FsMe+LUL"></a>One pitfall you&#8217;ll probably run into is that you can&#8217;t directly use
the node&#8217;s <code>childNodes</code> property as a collection of tab nodes. For one
thing, when you add the buttons, they will also become a child node,
and end up in this pseudo-array. For another, the text nodes created
for the whitespace between the nodes are also in there, and should not
get their own tabs.</p>
<p><a class=p_ident id="p_ZYln4fnwKS" href="#p_ZYln4fnwKS"></a>To work around this, start by building up a real array of all the
<code>nodeType</code> 1 children in the wrapper.</p>
<p><a class=p_ident id="p_trFuWDXdya" href="#p_trFuWDXdya"></a>When registering event handlers on the buttons, the handler functions
will need to know which tab element is associated with this button.
When they are created in a normal loop, accessing the loop index from
inside the function works, but won&#8217;t give the correct result, because
that index will have been further changed by the loop.</p>
<p><a class=p_ident id="p_6hWX45kZgb" href="#p_6hWX45kZgb"></a>A simple workaround is to use the <code>forEach</code> method and create the
handler function from inside the method&#8217;s argument function, where it
can access the function&#8217;s arguments, which are more stable.</p>
</div></div>
<nav>
  <a href="13_dom.html" title="previous chapter">⬅</a>
  <a href="index.html" title="cover">⬆</a>
  <a href="15_game.html" title="next chapter">➡</a>
</nav>
</article>
