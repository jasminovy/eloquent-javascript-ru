<!doctype html>
<head>
  <meta charset="utf-8">
  <title>Project: A Platform Game :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/node_modules/codemirror/lib/codemirror.js"></script>
  <script src="js/node_modules/codemirror/mode/javascript/javascript.js"></script>
  <script src="js/node_modules/codemirror/mode/css/css.js"></script>
  <script src="js/node_modules/codemirror/mode/xml/xml.js"></script>
  <script src="js/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <script src="js/node_modules/codemirror/addon/edit/matchbrackets.js"></script>
  <script src="js/node_modules/acorn/acorn.js"></script>
  <script src="js/node_modules/acorn/util/walk.js"></script>
  <link rel=stylesheet href="ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 15;var sandboxLoadFiles = ["js/15_game.js", "js/code/game_levels.js"];</script>
</head>

<article>
<nav>
  <a href="14_event.html" title="previous chapter">⬅</a>
  <a href="index.html" title="cover">⬆</a>
  <a href="16_canvas.html" title="next chapter">➡</a>
</nav>

<h1><div class=chap_num>Chapter 15</div>Project: A Platform Game</h1>
<p><a class=p_ident id="p_LHKzmIPa3c" href="#p_LHKzmIPa3c"></a>My initial fascination with computers, like that of many kids,
originated with computer games. I was drawn in by the tiny
computer-simulated worlds which I could manipulate and impact (sort
of). More, I suppose, because of the way I could project my
imagination into them, than because of the possibilities they actually
offered.</p>
<p><a class=p_ident id="p_3fmBK1qNPL" href="#p_3fmBK1qNPL"></a>I wouldn&#8217;t wish a career in game programming on anyone—much like in
the music industry, the discrepancy between the many eager young
people wanting to work in it and the actual demand for such people
creates a rather exploitative atmosphere. But writing games for fun can
be very rewarding. A game world, even when simple, is still a world.
Who doesn&#8217;t like creating worlds?</p>
<p><a class=p_ident id="p_j3t+HvGbaT" href="#p_j3t+HvGbaT"></a>This chapter will walk through the implementation of a simple platform
game. Platform games (or “jump and run” games) are games that involve
moving a figure through an (often two-dimensional, side-view) world,
and jumping onto and over things.</p>
<h2 id="_the_game">The game</h2>
<p><a class=p_ident id="p_C38xTPlNF8" href="#p_C38xTPlNF8"></a>Our game will be roughly based on “<a href="http://www.lessmilk.com/games/10">Dark
Blue</a>” by Thomas Palef. I chose
this game because it is extremely minimal (and thus implementable
without <em>too</em> much code), yet entertaining. It looks like this:</p>
<div class="image">
  <img src="img/darkblue.png" alt="The game Dark Blue">
</div>
<p><a class=p_ident id="p_mIXBfsCnQQ" href="#p_mIXBfsCnQQ"></a>The dark box represents the player, whose task it is to collect the
yellow boxes (coins) while avoiding the red stuff (lava?). A level is
completed when all coins have been collected.</p>
<p><a class=p_ident id="p_rcuUAo7AQI" href="#p_rcuUAo7AQI"></a>The player can walk around with the left and right arrow keys, and
jump with the up arrow. Jumping is the main occupation of this game
character. It can reach many times their own height, and is able to
change direction in mid-air. Though this may not be entirely
realistic, it helps give the player a feeling of being in direct
control of the on-screen avator.</p>
<p><a class=p_ident id="p_eKK9rBtPEi" href="#p_eKK9rBtPEi"></a>The game&#8217;s consist of a fixed background, laid out like a grid, with
the moving elements overlaid on that. Each field on the background
grid is either empty, solid, or lava. The moving elements are the
player, coins, and pieces of lava that move. Unlike the artificial
life simulation from Chapter 7, the positions of these elements are
not constrained to the grid—their coordinates may be fractional,
allowing smooth motion.</p>
<h2 id="_the_technology">The technology</h2>
<p><a class=p_ident id="p_w6B1L26QOc" href="#p_w6B1L26QOc"></a>We will use the browser DOM to display the game, and read user input
by handling key events.</p>
<p><a class=p_ident id="p_wha4Kv9EnE" href="#p_wha4Kv9EnE"></a>The screen- and keyboard-related code is only a tiny portion of the
work we need to do to implement this game. Since everything looks like
single-color boxes, drawing is uncomplicated: we create DOM elements,
and use styling to give them a background color, size, and position.</p>
<p><a class=p_ident id="p_5a/S/bF/ru" href="#p_5a/S/bF/ru"></a>We can represent the background, which is a static grid, as a table of
colored cells. The free-moving elements can be overlaid on top of that
using absolutely positioned elements.</p>
<p><a class=p_ident id="p_QrueUsofq6" href="#p_QrueUsofq6"></a>In games (and similar programs) that have to respond and animate
without noticeable delay, efficiency is an important concern. Though
the DOM was not originally designed for high-performance graphics, it
is surprisingly effective in that area. We saw some simple animations
in Chapter 13. On a modern machine, drawing a simple game like this
one will not require us to do anything special to get acceptable
performance.</p>
<p><a class=p_ident id="p_wN87+E1mRv" href="#p_wN87+E1mRv"></a>In the next chapter, we will explore another browser technology, the
<code>&lt;canvas&gt;</code> tag, which provides a way to draw graphics that is more
similar to traditional graphics interfaces—working in terms of shapes
and pixels, rather than DOM elements.</p>
<h2 id="_levels">Levels</h2>
<p><a class=p_ident id="p_qtbcbQFDkK" href="#p_qtbcbQFDkK"></a>In Chapter 7 we used arrays of strings to describe a two-dimensional
grid. That approach is useful here as well. It will allow us to easily
design levels without first building a level editor.</p>
<p><a class=p_ident id="p_qMHtsEuWk8" href="#p_qMHtsEuWk8"></a>This, for example, could specify a simple level:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_ydbtOFWK2H" href="#c_ydbtOFWK2H"></a><span class="cm-keyword">var</span> <span class="cm-variable">simpleLevelPlan</span> <span class="cm-operator">=</span> [
  <span class="cm-string">"                      "</span>,
  <span class="cm-string">"                      "</span>,
  <span class="cm-string">"  x              = x  "</span>,
  <span class="cm-string">"  x         o o    x  "</span>,
  <span class="cm-string">"  x @      xxxxx   x  "</span>,
  <span class="cm-string">"  xxxxx            x  "</span>,
  <span class="cm-string">"      x!!!!!!!!!!!!x  "</span>,
  <span class="cm-string">"      xxxxxxxxxxxxxx  "</span>,
  <span class="cm-string">"                      "</span>
];</pre>
<p><a class=p_ident id="p_83rgKffnW5" href="#p_83rgKffnW5"></a>Both the fixed grid and the moving elements are included in the
strings. We use “x” characters for walls, spaces for empty space, and
exclamation marks for fixed, non-moving lava tiles.</p>
<p><a class=p_ident id="p_tfgPG47asM" href="#p_tfgPG47asM"></a>The initial player position is indicated by an “@” character. Coins
will be put wherever there is an “o”, and the equals sign (“=”)
indicates a block of lava that moves back and forth horizontally. Note
that the grid for these positions will be set to contain empty space,
and an additional data structure will be used to track the position of
these non-fixed elements.</p>
<p><a class=p_ident id="p_upC/0R7u7D" href="#p_upC/0R7u7D"></a>We will also support a pipe character (“|”) for vertically moving
lava, and “v” for <em>dripping</em> lava—vertically moving blocks of lava
that don&#8217;t bounce back and forth, but move down and jump back to their
start position when they hit the floor.</p>
<p><a class=p_ident id="p_LGIsdJ3CvQ" href="#p_LGIsdJ3CvQ"></a>A whole game will be represented by an array of level arrays, though
which the player must progress one after the other, by collecting all
the coins in each. When the player touches lava, the current level is
simply restored to its starting position, and they can try again.</p>
<h2 id="_reading_a_level">Reading a level</h2>
<p><a class=p_ident id="p_qzTByN78mw" href="#p_qzTByN78mw"></a>The following constructor, given an array of strings as seen above,
constructs a level object.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_VxXFnA3vlY" href="#c_VxXFnA3vlY"></a><span class="cm-keyword">function</span> <span class="cm-variable">Level</span>(<span class="cm-def">plan</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">plan</span>[<span class="cm-number">0</span>].<span class="cm-property">length</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">plan</span>.<span class="cm-property">length</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">grid</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">this</span>.<span class="cm-property">actors</span> <span class="cm-operator">=</span> [];

  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">height</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">line</span> <span class="cm-operator">=</span> <span class="cm-variable-2">plan</span>[<span class="cm-variable-2">y</span>], <span class="cm-def">gridLine</span> <span class="cm-operator">=</span> [];
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">width</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">ch</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>[<span class="cm-variable-2">x</span>], <span class="cm-def">fieldType</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">Actor</span> <span class="cm-operator">=</span> <span class="cm-variable">actorChars</span>[<span class="cm-variable-2">ch</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">Actor</span>)
        <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">push</span>(<span class="cm-keyword">new</span> <span class="cm-variable-2">Actor</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>), <span class="cm-variable-2">ch</span>));
      <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"x"</span>)
        <span class="cm-variable-2">fieldType</span> <span class="cm-operator">=</span> <span class="cm-string">"wall"</span>;
      <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"!"</span>)
        <span class="cm-variable-2">fieldType</span> <span class="cm-operator">=</span> <span class="cm-string">"lava"</span>;
      <span class="cm-variable-2">gridLine</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">fieldType</span>);
    }
    <span class="cm-keyword">this</span>.<span class="cm-property">grid</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">gridLine</span>);
  }

  <span class="cm-keyword">this</span>.<span class="cm-property">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"player"</span>;
  })[<span class="cm-number">0</span>];
  <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
}</pre>
<p><a class=p_ident id="p_x/twI7oWfP" href="#p_x/twI7oWfP"></a>A level stores its width and height, along with two arrays—one for the
grid, and one for the <em>actors</em>, the dynamic elements. The grid is
represented as an array of arrays, where each of the inner arrays
represents a horizontal line of the grid, and each square contains
either null, for empty squares, or a string indicating the type of the
square—<code>"wall"</code> or <code>"lava"</code>.</p>
<p><a class=p_ident id="p_lk9TyBu+V9" href="#p_lk9TyBu+V9"></a>The actors array holds a number of objects that track the current
position and state of the dynamic elements in the level. Each of these
is expected to have a <code>pos</code> property giving its position (the
coordinates of its top left corner), a <code>size</code> property giving its
size, and a <code>type</code> property that holds a string that identifies the
element (<code>"lava"</code>, <code>"coin"</code>, or <code>"player"</code>).</p>
<p><a class=p_ident id="p_TlvqkqOEbF" href="#p_TlvqkqOEbF"></a>After building up the grid, we use the <code>filter</code> method to find the
player actor object, and store it in a property of the level. The
<code>status</code> and <code>finishDelay</code> properties will be used when the player
dies or wins, to show a simple animation rather than immediately
resetting or advancing the level (which would look cheap). This method
can be used to determine whether a level is finished:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_E07Ia0WqAe" href="#c_E07Ia0WqAe"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">isFinished</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>;
};</pre>
<p><a class=p_ident id="p_+4q7aJCqD3" href="#p_+4q7aJCqD3"></a>For brevity, this code assumes that level plans are well-formed—that
each line has the same length and only contains allowed characters,
and that there is a single player start position in it.</p>
<h2 id="_actors">Actors</h2>
<p><a class=p_ident id="p_C60UbiL689" href="#p_C60UbiL689"></a>To represent the position and size of an actor, we will return to our
trusty <code>Vector</code> type, which groups an x and y coordinate into an
object.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_/G1xAMXuR9" href="#c_/G1xAMXuR9"></a><span class="cm-keyword">function</span> <span class="cm-variable">Vector</span>(<span class="cm-def">x</span>, <span class="cm-def">y</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">x</span>; <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">y</span>;
}
<span class="cm-variable">Vector</span>.<span class="cm-property">prototype</span>.<span class="cm-property">plus</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">other</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">x</span>, <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">y</span>);
};
<span class="cm-variable">Vector</span>.<span class="cm-property">prototype</span>.<span class="cm-property">times</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>, <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>);
};</pre>
<p><a class=p_ident id="p_vHWAINR/V0" href="#p_vHWAINR/V0"></a>The <code>times</code> method scales a vector by a given factor, and will be
useful when we need to multiply a speed vector by a time interval.</p>
<p><a class=p_ident id="p_Y5LDrE3iuJ" href="#p_Y5LDrE3iuJ"></a>The <code>actorChars</code> object was used by the <code>Level</code> constructor to
associate characters with constructor functions. It looks like this:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_yAQDMv58Ql" href="#c_yAQDMv58Ql"></a><span class="cm-keyword">var</span> <span class="cm-variable">actorChars</span> <span class="cm-operator">=</span> {
  <span class="cm-string cm-property">"@"</span>: <span class="cm-variable">Player</span>,
  <span class="cm-string cm-property">"o"</span>: <span class="cm-variable">Coin</span>,
  <span class="cm-string cm-property">"="</span>: <span class="cm-variable">Lava</span>, <span class="cm-string cm-property">"|"</span>: <span class="cm-variable">Lava</span>, <span class="cm-string cm-property">"v"</span>: <span class="cm-variable">Lava</span>
};</pre>
<p><a class=p_ident id="p_yONLZQgPom" href="#p_yONLZQgPom"></a>There are three characters mapping to <code>Lava</code>. The <code>Level</code> constructor
passes the actor the character it was based on as an argument, which
the <code>Lava</code> constructor uses to determine its behavior (bouncing
horizontally or vertically, or dripping).</p>
<p><a class=p_ident id="p_9z5NweLFob" href="#p_9z5NweLFob"></a>The player type is built with this simple constructor. It has a
property <code>speed</code> containing its current speed, which we will
use to simulate momentum and gravity.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_GHc17EeS05" href="#c_GHc17EeS05"></a><span class="cm-keyword">function</span> <span class="cm-variable">Player</span>(<span class="cm-def">pos</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-operator">-</span><span class="cm-number">0.5</span>));
  <span class="cm-keyword">this</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0.8</span>, <span class="cm-number">1.5</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>);
}
<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">type</span> <span class="cm-operator">=</span> <span class="cm-string">"player"</span>;</pre>
<p><a class=p_ident id="p_WVgAUagO+H" href="#p_WVgAUagO+H"></a>When constructing a dynamic <code>Lava</code> object, we need to set up some
state based on the character it was based on. Moving lava will simply
move along at its given speed until it hits an obstacle. At that
point, if it has a <code>repeatPos</code> property, it will jump back to its
start position (dripping). If it does not, it will invert its speed
and continue in the other direction (bouncing). The constructor only
sets up the necessary properties—the method that does the actual
moving will be written later on.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_PTqOmT7FMn" href="#c_PTqOmT7FMn"></a><span class="cm-keyword">function</span> <span class="cm-variable">Lava</span>(<span class="cm-def">pos</span>, <span class="cm-def">ch</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">1</span>, <span class="cm-number">1</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"="</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">2</span>, <span class="cm-number">0</span>);
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"|"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-number">2</span>);
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"v"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-number">3</span>);
    <span class="cm-keyword">this</span>.<span class="cm-property">repeatPos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>;
  }
}
<span class="cm-variable">Lava</span>.<span class="cm-property">prototype</span>.<span class="cm-property">type</span> <span class="cm-operator">=</span> <span class="cm-string">"lava"</span>;</pre>
<p><a class=p_ident id="p_kCVlHBEEcx" href="#p_kCVlHBEEcx"></a><code>Coin</code> actors are very simple, and mostly sit statically in their
place. But to liven up the game a little, they are given a “wobble”, a
slight vertical motion back and forth. To track this, a coin object
stores both a current position and a base position (around which the
wobble happens), as well as a <code>wobble</code> property that tracks the phase
of the bouncing motion.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_SwVUgnkT5j" href="#c_SwVUgnkT5j"></a><span class="cm-keyword">function</span> <span class="cm-variable">Coin</span>(<span class="cm-def">pos</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">basePos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0.2</span>, <span class="cm-number">0.1</span>));
  <span class="cm-keyword">this</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0.6</span>, <span class="cm-number">0.6</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">wobble</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span> <span class="cm-operator">*</span> <span class="cm-number">2</span>;
}
<span class="cm-variable">Coin</span>.<span class="cm-property">prototype</span>.<span class="cm-property">type</span> <span class="cm-operator">=</span> <span class="cm-string">"coin"</span>;</pre>
<p><a class=p_ident id="p_uxsZ2jL44b" href="#p_uxsZ2jL44b"></a>To avoid a situation where all coins move up and down synchronously,
the starting phase of each coin is randomized. We will be using
<code>Math.sin</code> (a sine wave) to model the motion, so we multiply the value
returned by <code>Math.random</code> by 2π, which causes it to take a random
position on that wave. If none of this makes sense to you, don&#8217;t
worry, it is not necessary to understand it to follow the chapter.</p>
<p><a class=p_ident id="p_Dn6WCXhVEo" href="#p_Dn6WCXhVEo"></a>We now have all the parts needed to initialize a level.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_+UfzWNonW2" href="#c_+UfzWNonW2"></a><span class="cm-keyword">var</span> <span class="cm-variable">simpleLevel</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable">simpleLevelPlan</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">simpleLevel</span>.<span class="cm-property">width</span>, <span class="cm-string">"by"</span>, <span class="cm-variable">simpleLevel</span>.<span class="cm-property">height</span>);
<span class="cm-comment">// → 22 by 9</span></pre>
<h2 id="_encapsulation_as_a_burden">Encapsulation as a burden</h2>
<p><a class=p_ident id="p_M65QHGE4qM" href="#p_M65QHGE4qM"></a>Most of the code in this chapter will worry very little about
encapsulation. This has two reasons. Firstly, encapsulation takes
extra effort. It will make programs bigger and require additional
concepts and interfaces to be introduced. Since there is only so much
code you can throw at a reader before their eyes glaze over, I&#8217;ve made
an effort to keep the program small.</p>
<p><a class=p_ident id="p_SjFyUoye4F" href="#p_SjFyUoye4F"></a>Secondly, the various elements in this game are so closely tied
together that if the behavior of one of them changed, it is unlikely
that any of the others would be able to stay the same. Interfaces
between the elements would end up encoding a lot of assumptions about
the way the game works. This makes them a lot less effective—whenever
you make a change to one part of the system, you still have to worry
about the way it impacts the other parts, because their interfaces
wouldn&#8217;t cover the new situation.</p>
<p><a class=p_ident id="p_3SEhmyLQKJ" href="#p_3SEhmyLQKJ"></a>Some <em>cutting points</em> in a system lend themselves very well to
separation through rigorous interfaces , others don&#8217;t. Trying to
encapsulate something that isn&#8217;t a suitable boundary is a sure way to
waste a lot of energy. When you are making this mistake, you&#8217;ll
usually notice that your interfaces are getting awkwardly large and
detailed, and that they need to be modified often, as new requirements
come up.</p>
<p><a class=p_ident id="p_Eajw41C5DX" href="#p_Eajw41C5DX"></a>There is one thing that we <em>will</em> encapsulate in this chapter, and
that is the drawing subsystem. The reason for this is that we will
display the same game in a different way in the next chapter. By
putting the drawing behind an interface, we can simply load the same
game program there, but plug in a new display module.</p>
<h2 id="_drawing">Drawing</h2>
<p><a class=p_ident id="p_bjlUPfTgQP" href="#p_bjlUPfTgQP"></a>The encapsulation of the drawing code is done by defining a <em>display</em>
object, which displays a given level. The display type we define in
this chapter is called <code>DOMDisplay</code>, because it uses simple DOM
elements to show the level.</p>
<p><a class=p_ident id="p_LLiUyYKTA0" href="#p_LLiUyYKTA0"></a>We will be using a style sheet to set the actual colors and other
fixed properties of the elements that make up the game. It would also
be possible to directly assign to the elements' <code>style</code> property when
we create them, but that would produce rather verbose programs.</p>
<p><a class=p_ident id="p_cp0ecVNl6a" href="#p_cp0ecVNl6a"></a>The following helper function provides a short way to create an
element and give it a class.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_3+1i6r5ZQx" href="#c_3+1i6r5ZQx"></a><span class="cm-keyword">function</span> <span class="cm-variable">element</span>(<span class="cm-def">name</span>, <span class="cm-def">className</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">elt</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-variable-2">name</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">className</span>) <span class="cm-variable-2">elt</span>.<span class="cm-property">className</span> <span class="cm-operator">=</span> <span class="cm-variable-2">className</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">elt</span>;
}</pre>
<p><a class=p_ident id="p_Xjpq/reXQf" href="#p_Xjpq/reXQf"></a>A display is created by giving it a parent element to which it should
append itself, and a level object.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_jtVbluHgiz" href="#c_jtVbluHgiz"></a><span class="cm-keyword">function</span> <span class="cm-variable">DOMDisplay</span>(<span class="cm-def">parent</span>, <span class="cm-def">level</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span> <span class="cm-operator">=</span> <span class="cm-variable-2">parent</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">element</span>(<span class="cm-string">"div"</span>, <span class="cm-string">"game"</span>));
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">drawBackground</span>());
  <span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">drawFrame</span>();
}</pre>
<p><a class=p_ident id="p_ma7b253RBp" href="#p_ma7b253RBp"></a>We used the fact that <code>appendChild</code> returns the appended element to
create the wrapper element and store it in the <code>wrap</code> property in a
single statement.</p>
<p><a class=p_ident id="p_IMKo7SUQR3" href="#p_IMKo7SUQR3"></a>The level&#8217;s background, which never changes, is drawn once. The actors
are redrawn every time the display is updated. The <code>actorLayer</code>
property will be used by <code>drawFrame</code> to track the element that holds
the actors, so that they can be easily removed and replaced.</p>
<p><a class=p_ident id="p_si3+n3Lijy" href="#p_si3+n3Lijy"></a>Our coordinates and sizes are tracked in units relative to the grid
size, where a size or distance of one means one grid unit. When
setting pixel sizes, we will have to scale these coordinates up—things
would be ridiculously small at a single pixel per square. The <code>scale</code>
variable gives the amount of pixels a single unit takes up on the
screen.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_B0fxM6Afk5" href="#c_B0fxM6Afk5"></a><span class="cm-keyword">var</span> <span class="cm-variable">scale</span> <span class="cm-operator">=</span> <span class="cm-number">20</span>;

<span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawBackground</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">table</span> <span class="cm-operator">=</span> <span class="cm-variable">element</span>(<span class="cm-string">"table"</span>, <span class="cm-string">"background"</span>);
  <span class="cm-variable-2">table</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">width</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">grid</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">row</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">rowElt</span> <span class="cm-operator">=</span> <span class="cm-variable-2">table</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">element</span>(<span class="cm-string">"tr"</span>));
    <span class="cm-variable-2">rowElt</span>.<span class="cm-property">style</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">row</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">type</span>) {
      <span class="cm-variable-2">rowElt</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">element</span>(<span class="cm-string">"td"</span>, <span class="cm-variable-2">type</span>));
    });
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">table</span>;
};</pre>
<p><a class=p_ident id="p_d+zoai4uXa" href="#p_d+zoai4uXa"></a>As mentioned earlier, the background is drawn as a <code>&lt;table&gt;</code> element.
This nicely corresponds to the structure of the <code>grid</code> property in the
level—each row of the grid is turned into a table row (<code>&lt;tr&gt;</code>
element). The strings in the grid are used as class names for the
table cell (<code>&lt;td&gt;</code>) elements. The following CSS helps the resulting
table look like the background we want:</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class=c_ident id="c_MhF7n9+OyK" href="#c_MhF7n9+OyK"></a><span class="cm-qualifier">.background</span>    { <span class="cm-property">background</span>: <span class="cm-atom">#34a6fb</span>;
                 <span class="cm-property">table-layout</span>: <span class="cm-atom">fixed</span>;
                 <span class="cm-property">border-spacing</span>: <span class="cm-number">0</span>;   }
<span class="cm-qualifier">.background</span> <span class="cm-tag">td</span> { <span class="cm-property">padding</span>: <span class="cm-number">0</span>;          }
<span class="cm-qualifier">.lava</span>          { <span class="cm-property">background</span>: <span class="cm-atom">#ff6363</span>; }
<span class="cm-qualifier">.wall</span>          { <span class="cm-property">background</span>: <span class="cm-keyword">white</span>;   }</pre>
<p><a class=p_ident id="p_AOJ9RJXRsZ" href="#p_AOJ9RJXRsZ"></a>Some of these (<code>table-layout</code>, <code>border-spacing</code>, and <code>padding</code>) are
simply used to suppress unwanted default behavior. We don&#8217;t want space
between the table cells, or padding inside them, and we set the
table&#8217;s algorithm for computing the width of its columns to a simple,
predictable variant (the way tables are laid out in HTML is a very
complicated thing).</p>
<p><a class=p_ident id="p_rNPKPXOXhq" href="#p_rNPKPXOXhq"></a>The <code>background</code> rules set background colors. CSS allows colors to be
specified both as words (<code>white</code>) and with a rather cryptic <code>#RRGGBB</code>
format, where the hash sign is followed by pairs of hexadecimal
(base-16) digits giving first the red, then the green, and then the
blue components of the color, as numbers between zero and <code>ff</code> (255).
So in <code>#34a6fb</code> the the red component is hexadecimal <code>34</code> (3 × 16 + 4
equals decimal 52), green is <code>a6</code> (166), and blue <code>fb</code> (251). Since
the blue component is the largest, the resulting color will be
blueish. You can see that in the <code>.lava</code> rule, the first part of the
number (red) is the largest.</p>
<p><a class=p_ident id="p_mgOIyKXNXl" href="#p_mgOIyKXNXl"></a>Drawing the actors is quite straightforward:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_B/eObizkA/" href="#c_B/eObizkA/"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawActors</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">wrap</span> <span class="cm-operator">=</span> <span class="cm-variable">element</span>(<span class="cm-string">"div"</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">actors</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">elt</span> <span class="cm-operator">=</span> <span class="cm-variable-2">wrap</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">element</span>(<span class="cm-string">"div"</span>, <span class="cm-string">"actor "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">type</span>));
    <span class="cm-variable-2">elt</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">elt</span>.<span class="cm-property">style</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">elt</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">elt</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">wrap</span>;
};</pre>
<p><a class=p_ident id="p_Gvt8r7pb1I" href="#p_Gvt8r7pb1I"></a>Each actor gets an element, and we set the element&#8217;s position and size
based on the actor&#8217;s properties, multiplying each value by the display
<code>scale</code>.</p>
<p><a class=p_ident id="p_w3qZ6jg/84" href="#p_w3qZ6jg/84"></a>Giving an element multiple classes is done by separating the class
names with spaces. Below the relevant CSS code is shown. The <code>actor</code>
class gives the actors their absolute position, and their type name is
used to give them a color (lava actors use the same class as lava grid
squares, which we defined earlier):</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class=c_ident id="c_yy7L6RYn0i" href="#c_yy7L6RYn0i"></a><span class="cm-qualifier">.actor</span>  { <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>;  }
<span class="cm-qualifier">.coin</span>   { <span class="cm-property">background</span>: <span class="cm-atom">#f1e559</span>; }
<span class="cm-qualifier">.player</span> { <span class="cm-property">background</span>: <span class="cm-atom">#404040</span>; }</pre>
<p><a class=p_ident id="p_2QCxwCK5uQ" href="#p_2QCxwCK5uQ"></a>To update the display when the world changes, the <code>drawFrame</code> method
removes the old actor graphics, if any, and redraws them in their new
positions. It may be tempting to try and reuse the DOM elements for
actors, but that would seriously increase the way in which the display
code and the simulation code are tangled up. We&#8217;d need to have a way
to associate actors with elements, and the drawing code must know when
to remove elements when their actors vanish. For a simple game like
this, redrawing is fast enough.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_qkPcdGO1jk" href="#c_qkPcdGO1jk"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawFrame</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">removeChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">drawActors</span>());
  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">className</span> <span class="cm-operator">=</span> <span class="cm-string">"game "</span> <span class="cm-operator">+</span> (<span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">status</span> <span class="cm-operator">||</span> <span class="cm-string">""</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">scrollPlayerIntoView</span>();
};</pre>
<p><a class=p_ident id="p_LCW1c8evxj" href="#p_LCW1c8evxj"></a>By adding the level&#8217;s current status as a class name to the wrapper,
we can style the player actor slightly differently when the game is
won or lost. (We could also style other elements, like the background,
differently based on a class in one of their ancestor elements. CSS is
convenient like that.)</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class=c_ident id="c_e+5uOijKiS" href="#c_e+5uOijKiS"></a><span class="cm-qualifier">.lost</span> <span class="cm-qualifier">.player</span> {
  <span class="cm-property">background</span>: <span class="cm-atom">#a04040</span>;
}
<span class="cm-qualifier">.won</span> <span class="cm-qualifier">.player</span> {
  <span class="cm-property">box-shadow</span>: <span class="cm-number">-4px</span> <span class="cm-number">-7px</span> <span class="cm-number">8px</span> <span class="cm-keyword">white</span>, <span class="cm-number">4px</span> <span class="cm-number">-7px</span> <span class="cm-number">8px</span> <span class="cm-keyword">white</span>;
}</pre>
<p><a class=p_ident id="p_Ta1z3iQqo1" href="#p_Ta1z3iQqo1"></a>After touching lava, the player&#8217;s color turns dark red, hopefully
suggesting scorching. When the last coin has been collected, we use a
two white box shadows, one to the top left and one to the top right,
to create a white halo effect.</p>
<p><a class=p_ident id="p_lBuhYzCkDw" href="#p_lBuhYzCkDw"></a>We don&#8217;t assume that levels fit into the viewport. That is why the
<code>scrollPlayerIntoView</code> call is needed—it ensures that, if the level is
sticking out outside of the viewport, we scroll that viewport to make
sure the player is near its center. The following CSS gives the game&#8217;s
wrapping DOM element a maximum size, and ensures that anything that
sticks out is not displayed. We also give it a relative position, so
that the actors inside of it are positioned relative to its top left
corner.</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class=c_ident id="c_BblQSzixfX" href="#c_BblQSzixfX"></a><span class="cm-qualifier">.game</span> {
  <span class="cm-property">overflow</span>: <span class="cm-atom">hidden</span>;
  <span class="cm-property">max-width</span>: <span class="cm-number">600px</span>;
  <span class="cm-property">max-height</span>: <span class="cm-number">450px</span>;
  <span class="cm-property">position</span>: <span class="cm-atom">relative</span>;
}</pre>
<p><a class=p_ident id="p_1/wCuAnu9B" href="#p_1/wCuAnu9B"></a>In the <code>scrollPlayerIntoView</code> method, we find the player&#8217;s position,
and update the wrapping element&#8217;s scroll position, by manipulating it&#8217;s
<code>scrollLeft</code> and <code>scrollTop</code> properties, when the player is too close
to the edge.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_h0khCqSfcE" href="#c_h0khCqSfcE"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">scrollPlayerIntoView</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">width</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">clientWidth</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">height</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">clientHeight</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">margin</span> <span class="cm-operator">=</span> <span class="cm-variable-2">width</span> <span class="cm-operator">/</span> <span class="cm-number">3</span>;

  <span class="cm-comment">// The viewport</span>
  <span class="cm-keyword">var</span> <span class="cm-def">left</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollLeft</span>, <span class="cm-def">right</span> <span class="cm-operator">=</span> <span class="cm-variable-2">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">width</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">top</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollTop</span>, <span class="cm-def">bottom</span> <span class="cm-operator">=</span> <span class="cm-variable-2">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">height</span>;

  <span class="cm-keyword">var</span> <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">player</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">center</span> <span class="cm-operator">=</span> <span class="cm-variable-2">player</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">player</span>.<span class="cm-property">size</span>.<span class="cm-property">times</span>(<span class="cm-number">0.5</span>))
                 .<span class="cm-property">times</span>(<span class="cm-variable">scale</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollLeft</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">></span> <span class="cm-variable-2">right</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollLeft</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">width</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollTop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">></span> <span class="cm-variable-2">bottom</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollTop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">height</span>;
};</pre>
<p><a class=p_ident id="p_3qHzB4KoD+" href="#p_3qHzB4KoD+"></a>The way the player&#8217;s center is found shows how the methods on our
<code>Vector</code> type allow rather natural-looking computations to be done
with objects. To find the actor&#8217;s center, we add its position (its top
left corner) half its size. That is the center in level coordinates,
but we need it in pixel coordinates, so we then multiply the resulting
vector by our display scale.</p>
<p><a class=p_ident id="p_Wo8jzvfVmy" href="#p_Wo8jzvfVmy"></a>Next, a series of checks verify that the player position isn&#8217;t outside
of the allowed range. Note that sometimes this will set nonsense
scroll coordinates, below zero or beyond the element&#8217;s scrollable
area. This is okay—the DOM will constrain them to sane values. Setting
<code>scrollLeft</code> to -10 will cause it to become zero.</p>
<p><a class=p_ident id="p_a8e7HASl2l" href="#p_a8e7HASl2l"></a>It would have been slightly simpler to always try to scroll the player
to the center of the viewport. But this creates a rather jarring
effect. As you are jumping, the view will constantly shift up and
down. Having it move up as you jump close to the edge, and then stay
there, is more pleasant.</p>
<p><a class=p_ident id="p_5o/NVpkfaU" href="#p_5o/NVpkfaU"></a>Finally, we&#8217;ll need a way to clear a displayed level, to be used when
the game moves on to the next level or resets a level.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_MTWKiFt3b3" href="#c_MTWKiFt3b3"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">clear</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">removeChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>);
};</pre>
<p><a class=p_ident id="p_pPzxkUqdeu" href="#p_pPzxkUqdeu"></a>We should now be able to display our tiny level:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_8o+3DwUj0x" href="#c_8o+3DwUj0x"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">></span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">simpleLevel</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable">simpleLevelPlan</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">DOMDisplay</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable">simpleLevel</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_CLn8fpSTCw" href="#p_CLn8fpSTCw"></a>The <code>&lt;link&gt;</code> tag, when used with <code>rel="stylesheet"</code>, is a way to load
a CSS file into a page. The file <code>game.css</code> contains the styles
necessary for our game.</p>
<h2 id="_motion_and_collision">Motion and collision</h2>
<p><a class=p_ident id="p_Ydh6WpgzzX" href="#p_Ydh6WpgzzX"></a>Now we get to the point where we can start adding motion—the most
interesting aspect of this game. The basic approach, which most games
like this take, is to split time into small steps, and for each step,
move the actors by a distance corresponding to their speed (distance
moved per second) multiplied by the size of the time step (in
seconds).</p>
<p><a class=p_ident id="p_+a3yt6NY8z" href="#p_+a3yt6NY8z"></a>That is easy. The difficult part is to deal with the interactions
between the elements. When the player hits a wall or floor, they
should not simply move through it. The game must notice when a given
motion causes an object to hit another object, and respond
accordingly—for walls, the motion must be stopped, for coins, the coin
collected, and so on.</p>
<p><a class=p_ident id="p_jcFn7w8EZK" href="#p_jcFn7w8EZK"></a>Solving this in the general case is quite a big undertaking. You can
find libraries, usually called <em>physics engines</em>, that simulate
interaction between physical objects in two or three dimensions. We&#8217;ll
take a more modest approach in this chapter, handling only collisions
between boxes, and handling them in a rather simplistic way.</p>
<p><a class=p_ident id="p_qnEGluIxK3" href="#p_qnEGluIxK3"></a>Before moving the player or a block of lava, we test whether the
motion would take it inside of a non-empty part of the background. If
it does, we simply cancel the motion altogether. The response to such
a collision depends on the type of actor—the player will stop, whereas
a lava block will bounce back.</p>
<p><a class=p_ident id="p_Y/iDVnt+Uc" href="#p_Y/iDVnt+Uc"></a>This approach requires our time steps to be rather small, since it
will cause motion to stop before the objects actually touch. If the
time steps, and thus the motion steps, are too big, the player would
end up hovering a noticeable distance above the ground. Another
approach, arguably better but more complicated, would be to find the
exact collision spot, and move there. We will take the simple
approach, and hide its problems by ensuring the animation proceeds in
small steps.</p>
<p><a class=p_ident id="p_mgrJ3S203s" href="#p_mgrJ3S203s"></a>This method tells us whether a rectangle (specified by a position and
a size) overlaps with any non-empty space on the background grid:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Hcer+ulFYg" href="#c_Hcer+ulFYg"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">obstacleAt</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">pos</span>, <span class="cm-def">size</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">xStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">xEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">size</span>.<span class="cm-property">x</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">size</span>.<span class="cm-property">y</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">xStart</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span> <span class="cm-operator">||</span> <span class="cm-variable-2">xEnd</span> <span class="cm-operator">></span> <span class="cm-keyword">this</span>.<span class="cm-property">width</span> <span class="cm-operator">||</span> <span class="cm-variable-2">yStart</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>)
    <span class="cm-keyword">return</span> <span class="cm-string">"wall"</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">yEnd</span> <span class="cm-operator">></span> <span class="cm-keyword">this</span>.<span class="cm-property">height</span>)
    <span class="cm-keyword">return</span> <span class="cm-string">"lava"</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">yStart</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">yEnd</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">xStart</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">xEnd</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">fieldType</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">grid</span>[<span class="cm-variable-2">y</span>][<span class="cm-variable-2">x</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">fieldType</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">fieldType</span>;
    }
  }
};</pre>
<p><a class=p_ident id="p_s4f/zXt7Pl" href="#p_s4f/zXt7Pl"></a>It computes the set of grid squares that the body overlaps with by
using <code>Math.floor</code> and <code>Math.ceil</code> on its coordinates. Remember that
grid squares are one by one unit in size. By rounding the sides of a
box up and down, we get the range of background squares that the box
touches.</p>
<div class="image">
  <img src="img/game-grid.svg" alt="Finding collisions on a grid">
</div>
<p><a class=p_ident id="p_MZ2cPIh/k/" href="#p_MZ2cPIh/k/"></a>If the body sticks out of the level, we return a predetermined
obstacle type—<code>"wall"</code> for the sides and top, <code>"lava"</code> for the bottom.
When it is fully inside of the grid, we loop over the block of grid
squares found by rounding the coordinates, and return the content of
the first non-empty square we find.</p>
<p><a class=p_ident id="p_oAeaIvbuEY" href="#p_oAeaIvbuEY"></a>Collisions between the player and other dynamic actors (coins, moving
lava) are handled <em>after</em> the player moved. When the motion has taken
it into another other actor, the appropriate effect—collecting a
coin or dying—is activated.</p>
<p><a class=p_ident id="p_a7cyC7K+cz" href="#p_a7cyC7K+cz"></a>This method scans through the array of actors, looking for an actor
that overlaps the one given as an argument, without actually being the
same actor.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_pSCf8V7nxy" href="#c_pSCf8V7nxy"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">actorAt</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">other</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">other</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">actor</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">></span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">></span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span>)
      <span class="cm-keyword">return</span> <span class="cm-variable-2">other</span>;
  }
};</pre>
<h2 id="_actors_and_actions">Actors and actions</h2>
<p><a class=p_ident id="p_+m6dCA3a5b" href="#p_+m6dCA3a5b"></a>The <code>animate</code> method, which we add to the <code>Level</code> type below, is
responsible for giving the actors in the level a chance to move.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_vOVw1aS8eJ" href="#c_vOVw1aS8eJ"></a><span class="cm-keyword">var</span> <span class="cm-variable">maxStep</span> <span class="cm-operator">=</span> <span class="cm-number">0.05</span>;

<span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">animate</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">step</span>;

  <span class="cm-keyword">while</span> (<span class="cm-variable-2">step</span> <span class="cm-operator">></span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">thisStep</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable">maxStep</span>);
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
      <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>[<span class="cm-variable-2">i</span>].<span class="cm-property">act</span>(<span class="cm-variable-2">thisStep</span>, <span class="cm-keyword">this</span>, <span class="cm-variable-2">keys</span>);
    <span class="cm-variable-2">step</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">thisStep</span>;
  }
};</pre>
<p><a class=p_ident id="p_3CL3X0Momn" href="#p_3CL3X0Momn"></a>When the level&#8217;s <code>status</code> property has a non-null value (which is the
case when the player has won or lost), we must count down the
<code>finishDelay</code> property, which tracks the time between the point where
winning or losing happens, and the point where we actually want to
stop showing the level.</p>
<p><a class=p_ident id="p_1RlyY9ZKcW" href="#p_1RlyY9ZKcW"></a>The <code>while</code> loop is responsible for cutting the time step we are
animating into suitably small pieces. It ensures that no step larger
than <code>maxStep</code> is taken. For example, a <code>step</code> of 0.12 second would be
cut into two steps of 0.05 second, and one of 0.02.</p>
<p><a class=p_ident id="p_E1SggqyLlQ" href="#p_E1SggqyLlQ"></a>Actor objects are supposed to implement an <code>act</code> method, which is
given as arguments the time step, the level object, and an object with
information about the keys the player is holding down. Here is a
simple one, for the <code>Lava</code> actor type:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_y3oz8d4Sdf" href="#c_y3oz8d4Sdf"></a><span class="cm-variable">Lava</span>.<span class="cm-property">prototype</span>.<span class="cm-property">act</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">times</span>(<span class="cm-variable-2">step</span>));
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">level</span>.<span class="cm-property">obstacleAt</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>))
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">repeatPos</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">repeatPos</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">times</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>);
};</pre>
<p><a class=p_ident id="p_hQ66AcUb17" href="#p_hQ66AcUb17"></a>It computes a new position by adding the product of the time step and
its current speed to its old position. If no obstacle blocks that new
position, it moves there. If there is an obstacle, the behavior
depends on the type of moving lava this is—dripping lava has a
<code>repeatPos</code> property, to which it jumps back when it hits something.
Bouncing lava simply inverts its speed (multiplies it by -1) in order
to start moving in the other direction.</p>
<p><a class=p_ident id="p_o7Hsk6jUq2" href="#p_o7Hsk6jUq2"></a>Coins need to update their wobble phase in their <code>act</code> method:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_CVksWY2lbJ" href="#c_CVksWY2lbJ"></a><span class="cm-keyword">var</span> <span class="cm-variable">wobbleSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">8</span>, <span class="cm-variable">wobbleDist</span> <span class="cm-operator">=</span> <span class="cm-number">0.07</span>;

<span class="cm-variable">Coin</span>.<span class="cm-property">prototype</span>.<span class="cm-property">act</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">wobble</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span> <span class="cm-operator">*</span> <span class="cm-variable">wobbleSpeed</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">wobblePos</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-keyword">this</span>.<span class="cm-property">wobble</span>) <span class="cm-operator">*</span> <span class="cm-variable">wobbleDist</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">basePos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">wobblePos</span>));
};</pre>
<p><a class=p_ident id="p_idEmgZRGVQ" href="#p_idEmgZRGVQ"></a>The <code>wobble</code> property is updated to track time, and then used as
argument to <code>Math.sin</code> to create a wave, which is used to compute a
new position. Coins don&#8217;t detect collisions. Their motion is defined
in such a way that it stays within their starting square, and
collision with the player is handled by the player&#8217;s <code>act</code> method.</p>
<p><a class=p_ident id="p_lgO1GBNxI4" href="#p_lgO1GBNxI4"></a>Which is the next things we get to. Player motion is separated per
axis, because hitting the floor should not prevent horizontal motion,
and hitting a wall should not stop falling or jumping motion. The
method below implements the horizontal part.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Fx/WuBkAiY" href="#c_Fx/WuBkAiY"></a><span class="cm-keyword">var</span> <span class="cm-variable">playerXSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">7</span>;

<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">moveX</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">left</span>) <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">-=</span> <span class="cm-variable">playerXSpeed</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">right</span>) <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">+=</span> <span class="cm-variable">playerXSpeed</span>;

  <span class="cm-keyword">var</span> <span class="cm-def">motion</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">step</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">motion</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">obstacle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>.<span class="cm-property">obstacleAt</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">obstacle</span>)
    <span class="cm-variable-2">level</span>.<span class="cm-property">playerTouched</span>(<span class="cm-variable-2">obstacle</span>);
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
};</pre>
<p><a class=p_ident id="p_GAwlbQhEnk" href="#p_GAwlbQhEnk"></a>The motion is computed based on the state of the left and right arrow
keys. When it would cause the player to hit something, the
<code>playerTouched</code> method for the level, which handles things like dying
in lava and collecting coins, is called. Otherwise, the object updates
its position.</p>
<p><a class=p_ident id="p_RFjA3kT0wu" href="#p_RFjA3kT0wu"></a>The vertical motion works in a comparable way, but has to take jumping
and gravity into account.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_nhIKELnUoo" href="#c_nhIKELnUoo"></a><span class="cm-keyword">var</span> <span class="cm-variable">gravity</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">jumpSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">17</span>;

<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">moveY</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span> <span class="cm-operator">*</span> <span class="cm-variable">gravity</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">motion</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">step</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">motion</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">obstacle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>.<span class="cm-property">obstacleAt</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">obstacle</span>) {
    <span class="cm-variable-2">level</span>.<span class="cm-property">playerTouched</span>(<span class="cm-variable-2">obstacle</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">up</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">></span> <span class="cm-number">0</span>)
      <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-variable">jumpSpeed</span>;
    <span class="cm-keyword">else</span>
      <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
  }
};</pre>
<p><a class=p_ident id="p_3htxZfwXa5" href="#p_3htxZfwXa5"></a>At the start of the method, the player&#8217;s vertical speed is updated for
gravity. The gravity, jumping speed, and pretty much all other
constants in this game, have been set by trial-and-error. I tried out
various values to see how they felt.</p>
<p><a class=p_ident id="p_94oTVZ3HNH" href="#p_94oTVZ3HNH"></a>We then check for obstacles again. If we are hitting an obstacle,
there are two possible outcomes. When the up arrow is pressed, <em>and</em>
we are moving down (meaning the thing we hit is below us), the speed
is set to a relatively large, negative value. This causes the player
to jump. If that is not the case, we simply bumped into something, and
the speed is reset to zero.</p>
<p><a class=p_ident id="p_YCAh/Cx+MG" href="#p_YCAh/Cx+MG"></a>The actual <code>act</code> method looks like this:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_xxPyq2OH/6" href="#c_xxPyq2OH/6"></a><span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">act</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">moveX</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable-2">level</span>, <span class="cm-variable-2">keys</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">moveY</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable-2">level</span>, <span class="cm-variable-2">keys</span>);

  <span class="cm-keyword">var</span> <span class="cm-def">otherActor</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>.<span class="cm-property">actorAt</span>(<span class="cm-keyword">this</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">otherActor</span>)
    <span class="cm-variable-2">level</span>.<span class="cm-property">playerTouched</span>(<span class="cm-variable-2">otherActor</span>.<span class="cm-property">type</span>, <span class="cm-variable-2">otherActor</span>);

  <span class="cm-comment">// Losing animation</span>
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">level</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">step</span>;
  }
};</pre>
<p><a class=p_ident id="p_qLDbHgcQb7" href="#p_qLDbHgcQb7"></a>After moving, it checks for other actors that it is colliding with,
and again calls <code>playerTouched</code> when it finds one. This time, it
passes the actor object as second argument, because if the other actor
is a coin, <code>playerTouched</code> needs to know which one is being collected.</p>
<p><a class=p_ident id="p_ZvTlzr2mKf" href="#p_ZvTlzr2mKf"></a>Finally, when the player died (touched lava) we set up a little
animation that causes them to “shrink” or “sink” down, by reducing the
height of the player object.</p>
<p><a class=p_ident id="p_ax6pc274qT" href="#p_ax6pc274qT"></a>And here is the method that handles collisions between the player and
other objects:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_oSIBfHTIP1" href="#c_oSIBfHTIP1"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">playerTouched</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">type</span>, <span class="cm-def">actor</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">type</span> <span class="cm-operator">==</span> <span class="cm-string">"lava"</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-string">"lost"</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">type</span> <span class="cm-operator">==</span> <span class="cm-string">"coin"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">splice</span>(<span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">actor</span>), <span class="cm-number">1</span>);
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">some</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"coin"</span>;
    })) {
      <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-string">"won"</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
    }
  }
};</pre>
<p><a class=p_ident id="p_2TZ51jE0Cq" href="#p_2TZ51jE0Cq"></a>When lava is touched, the game&#8217;s status is set to <code>"lost"</code>. When a
coin is touched, that coin is removed from the array of actors, and if
it was the last one, the game&#8217;s status is set to <code>"won"</code>.</p>
<p><a class=p_ident id="p_KJPecJ2C8w" href="#p_KJPecJ2C8w"></a>The <code>splice</code> method is used to cut a piece out of an array. It is
given an index and a number of elements, and removes that many
elements starting at the given index. In this case, we remove a single
element, our coin actor, whose index we found by calling <code>indexOf</code>.
Additional arguments can be given to <code>splice</code>, and they will be
inserted into the array at the given position, replacing the removed
elements.</p>
<p><a class=p_ident id="p_bf+I+YRgGu" href="#p_bf+I+YRgGu"></a>That gives us a level that can actually be animated. All that&#8217;s
missing now is the code that <em>drives</em> the animation.</p>
<h2 id="_tracking_keys">Tracking keys</h2>
<p><a class=p_ident id="p_6qSDIbEzkh" href="#p_6qSDIbEzkh"></a>For a game like this, we do not want keys to take effect once per
press. Rather, we want their effect (moving the player figure) to
continue happening as long as they are pressed.</p>
<p><a class=p_ident id="p_kKDop4NY9B" href="#p_kKDop4NY9B"></a>We need to set up a key handler that stores the current state of the
left, right, and up keys. We will also want to call <code>preventDefault</code>
for those keys, so that they don&#8217;t end up scrolling the page.</p>
<p><a class=p_ident id="p_SodsFdWG16" href="#p_SodsFdWG16"></a>The function below, when given an object with key codes as property
names and key names as value, will return an object that tracks the
current position of those keys. It registers event handlers for
<code>"keydown"</code> and <code>"keyup"</code> events, and when the key code in the event
is present in the set of codes that it is tracking, update the object.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_K9C8y+cteW" href="#c_K9C8y+cteW"></a><span class="cm-keyword">var</span> <span class="cm-variable">arrowCodes</span> <span class="cm-operator">=</span> {<span class="cm-number cm-property">37</span>: <span class="cm-string">"left"</span>, <span class="cm-number cm-property">38</span>: <span class="cm-string">"up"</span>, <span class="cm-number cm-property">39</span>: <span class="cm-string">"right"</span>};

<span class="cm-keyword">function</span> <span class="cm-variable">trackKeys</span>(<span class="cm-def">codes</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">pressed</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">handler</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">codes</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span>)) {
      <span class="cm-keyword">var</span> <span class="cm-def">state</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"keydown"</span>;
      <span class="cm-variable-2">pressed</span>[<span class="cm-variable-2">codes</span>[<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span>]] <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>;
      <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
    }
  }
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keydown"</span>, <span class="cm-variable-2">handler</span>);
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keyup"</span>, <span class="cm-variable-2">handler</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">pressed</span>;
}</pre>
<p><a class=p_ident id="p_ijH6rqUGtM" href="#p_ijH6rqUGtM"></a>Note how the same handler function is used for both event types. It
looks at the event object&#8217;s <code>type</code> property to determine whether the
key state should be updated to true (<code>"keydown"</code>) or false
(<code>"keyup"</code>).</p>
<h2 id="_running_the_game">Running the game</h2>
<p><a class=p_ident id="p_3fS5a/SYfz" href="#p_3fS5a/SYfz"></a>The <code>requestAnimationFrame</code> function, which we saw in Chapter 13,
provides a good way to animate a game. But its interface is quite
primitive—using it requires us to track the last time value we saw,
and re-call the <code>requestAnimationFrame</code> function after every frame.</p>
<p><a class=p_ident id="p_Yolq2zDVzm" href="#p_Yolq2zDVzm"></a>Here is a helper function that wraps those boring parts in a
convenient interface, and allows us to simply call <code>runAnimation</code>,
giving it a function that expects a time difference as argument and
draws a single frame. When the frame function returns the value
<code>false</code>, the animation stops.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_1AHi38WBun" href="#c_1AHi38WBun"></a><span class="cm-keyword">function</span> <span class="cm-variable">runAnimation</span>(<span class="cm-def">frameFunc</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">lastTime</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">function</span> <span class="cm-def">frame</span>(<span class="cm-def">time</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">stop</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">lastTime</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">timeStep</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">time</span> <span class="cm-operator">-</span> <span class="cm-variable-2">lastTime</span>, <span class="cm-number">100</span>) <span class="cm-operator">/</span> <span class="cm-number">1000</span>;
      <span class="cm-variable-2">stop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">frameFunc</span>(<span class="cm-variable-2">timeStep</span>) <span class="cm-operator">===</span> <span class="cm-atom">false</span>;
    }
    <span class="cm-variable-2">lastTime</span> <span class="cm-operator">=</span> <span class="cm-variable-2">time</span>;
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">stop</span>)
      <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable-2">frame</span>);
  }
  <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable-2">frame</span>);
}</pre>
<p><a class=p_ident id="p_qaBaJbkLcb" href="#p_qaBaJbkLcb"></a>I have set a maximum frame step of 100 milliseconds (one tenth of a
second). When the browser tab or window with our page is hidden,
<code>requestAnimationFrame</code> calls will be suspended until it is shown
again. In this case, the difference between <code>lastTime</code> and <code>time</code> will
be the entire time in which the page was hidden. Advancing the game by
that much in a single step will look silly, and might be a lot of work
(remember the time-splitting in the <code>animate</code> method).</p>
<p><a class=p_ident id="p_jKakPLUmwL" href="#p_jKakPLUmwL"></a>The function also converts the time steps to seconds, which are an
easier quantity to think about than milliseconds.</p>
<p><a class=p_ident id="p_e8mbmQ7w8j" href="#p_e8mbmQ7w8j"></a>The <code>runLevel</code> function takes a <code>Level</code> object, a constructor for a
display, and optionally a function. It display the level (in
<code>document.body</code>), and lets the user play through it. When the level is
finished (lost or won) it clears the display, stops the animation, and
if an <code>andThen</code> function was given, calls it with the level&#8217;s status.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_x5O5o5qg7u" href="#c_x5O5o5qg7u"></a><span class="cm-keyword">var</span> <span class="cm-variable">arrows</span> <span class="cm-operator">=</span> <span class="cm-variable">trackKeys</span>(<span class="cm-variable">arrowCodes</span>);

<span class="cm-keyword">function</span> <span class="cm-variable">runLevel</span>(<span class="cm-def">level</span>, <span class="cm-def">Display</span>, <span class="cm-def">andThen</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable-2">Display</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable-2">level</span>);
  <span class="cm-variable">runAnimation</span>(<span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
    <span class="cm-variable-2">level</span>.<span class="cm-property">animate</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable">arrows</span>);
    <span class="cm-variable-2">display</span>.<span class="cm-property">drawFrame</span>(<span class="cm-variable-2">step</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">level</span>.<span class="cm-property">isFinished</span>()) {
      <span class="cm-variable-2">display</span>.<span class="cm-property">clear</span>();
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">andThen</span>)
        <span class="cm-variable-2">andThen</span>(<span class="cm-variable-2">level</span>.<span class="cm-property">status</span>);
      <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
    }
  });
}</pre>
<p><a class=p_ident id="p_eyKzVe0sIB" href="#p_eyKzVe0sIB"></a>A game is a sequence of levels. Whenever the player dies, the current
level is restarted. When a level is completed, we move on to the next
level. This can be expressed by the following function, which takes an
array of level plans (arrays of strings) and a display constructor:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_rvuZqifpeI" href="#c_rvuZqifpeI"></a><span class="cm-keyword">function</span> <span class="cm-variable">runGame</span>(<span class="cm-def">plans</span>, <span class="cm-def">Display</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">startLevel</span>(<span class="cm-def">n</span>) {
    <span class="cm-variable">runLevel</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable-2">plans</span>[<span class="cm-variable-2">n</span>]), <span class="cm-variable-2">Display</span>, <span class="cm-keyword">function</span>(<span class="cm-def">status</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>)
        <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span>);
      <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">plans</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>)
        <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>);
      <span class="cm-keyword">else</span>
        <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You win!"</span>);
    });
  }
  <span class="cm-variable-2">startLevel</span>(<span class="cm-number">0</span>);
}</pre>
<p><a class=p_ident id="p_Btjn/eg/VT" href="#p_Btjn/eg/VT"></a>These functions show a peculiar style of programming. Both
<code>runAnimation</code> and <code>runLevel</code> are higher-order functions, but not in
the style we saw in Chapter 5. The function argument is used to
arrange things to happen at some time in the future, and neither of
the functions returns anything useful. Their task is, in a way, to
schedule actions. Wrapping these actions in functions gives us a way
to store them as a value, so that they can be called at the right
moment.</p>
<p><a class=p_ident id="p_iX8Vb//b7y" href="#p_iX8Vb//b7y"></a>This programming style is usually called <em>asynchronous</em> programming.
Event handling is also an instance of it, and we will see much more of
it when working with tasks that can take an arbitrary amount of time,
such as network requests in Chapter 17, and in- and output in general
in Chapter 21 (FIXME).</p>
<p><a class=p_ident id="p_/6dLhjN2fB" href="#p_/6dLhjN2fB"></a>There is a set of level plans available in the <code>GAME_LEVELS</code> variable
. This page
feeds them to <code>runGame</code>, starting an actual game:</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="null" data-focus="true"><a class=c_ident id="c_oaEDJYZVSb" href="#c_oaEDJYZVSb"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">></span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_MkrZ67rFcA" href="#p_MkrZ67rFcA"></a>See if you can beat those. I had quite a lot of fun building them.</p>
<h2 id="_exercises">Exercises</h2>
<h3 id="_game_over">Game over</h3>
<p><a class=p_ident id="p_dbW1awnMRB" href="#p_dbW1awnMRB"></a>It is tradition for platform games to have the player start with a
limited number of <em>lives</em>, and subtract one life each time they die.
When out of lives, the game restarts from the beginning.</p>
<p><a class=p_ident id="p_VZ7vg+hv2H" href="#p_VZ7vg+hv2H"></a>Adjust <code>runGame</code> to implement lives (have the player start with 3).</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class=c_ident id="c_dMQz3BJgE4" href="#c_dMQz3BJgE4"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">></span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-comment">// The old runGame function. Modify it...</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">runGame</span>(<span class="cm-def">plans</span>, <span class="cm-def">Display</span>) {
    <span class="cm-keyword">function</span> <span class="cm-def">startLevel</span>(<span class="cm-def">n</span>) {
      <span class="cm-variable">runLevel</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable-2">plans</span>[<span class="cm-variable-2">n</span>]), <span class="cm-variable-2">Display</span>, <span class="cm-keyword">function</span>(<span class="cm-def">status</span>) {
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>)
          <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span>);
        <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">plans</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>)
          <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>);
        <span class="cm-keyword">else</span>
          <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You win!"</span>);
      });
    }
    <span class="cm-variable-2">startLevel</span>(<span class="cm-number">0</span>);
  }
  <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_n7botbYRDO" href="#p_n7botbYRDO"></a>The most obvious solution would be to make <code>lives</code> a variable that
lives in <code>runGame</code>, and is thus visible by the <code>startLevel</code> closure.</p>
<p><a class=p_ident id="p_PlMiAVziM0" href="#p_PlMiAVziM0"></a>Another approach, which fits nicely with spirit of the rest of the
function, would be to add a second argument to <code>startLevel</code> that gives
the amount of lives. When the whole state of a system stored in the
arguments to a function, calling that function provides an elegant way
to transition to a new state.</p>
<p><a class=p_ident id="p_2xJcBQOfjW" href="#p_2xJcBQOfjW"></a>In any case, when a level is lost, there should now be two possible
state transitions: if that was the last life, we go back to level zero
with the starting amount of lives. If not, we repeat the current level
with one less life remaining.</p>
</div></div>
<h3 id="_pausing_the_game">Pausing the game</h3>
<p><a class=p_ident id="p_CQGTLIPI1L" href="#p_CQGTLIPI1L"></a>Make it possible to pause (suspend) and unpause the game by pressing
the Escape key.</p>
<p><a class=p_ident id="p_FpramcVlTZ" href="#p_FpramcVlTZ"></a>This can be done by changing the <code>runLevel</code> function to use another
keyboard event handler, and interrupting or resuming the animation
whenever the Escape key is hit.</p>
<p><a class=p_ident id="p_vlGSY83Wnl" href="#p_vlGSY83Wnl"></a>The <code>runAnimation</code> interface may not look like it is suitable for
this, at first glance, but it is, if you rearrange the way <code>runLevel</code>
calls it.</p>
<p><a class=p_ident id="p_0zF8rh7TLp" href="#p_0zF8rh7TLp"></a>When you have that working, there is something else you could try. The
way we have been registering keyboard event handlers is somewhat
problematic. The <code>arrows</code> object is currently a global variable, and
its event handlers are kept around even when no game is running. They
<em>leak</em> out of our system, you could say. Extend <code>trackKeys</code> to provide
a way to unregister its handlers, and then change <code>runLevel</code> to
register its handlers when it starts, and unregister them again when
it is finished.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class=c_ident id="c_surIcbdAwo" href="#c_surIcbdAwo"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">></span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-comment">// The old runLevel function. Modify this...</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">runLevel</span>(<span class="cm-def">level</span>, <span class="cm-def">Display</span>, <span class="cm-def">andThen</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable-2">Display</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable-2">level</span>);
    <span class="cm-variable">runAnimation</span>(<span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
      <span class="cm-variable-2">level</span>.<span class="cm-property">animate</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable">arrows</span>);
      <span class="cm-variable-2">display</span>.<span class="cm-property">drawFrame</span>(<span class="cm-variable-2">step</span>);
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">level</span>.<span class="cm-property">isFinished</span>()) {
        <span class="cm-variable-2">display</span>.<span class="cm-property">clear</span>();
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">andThen</span>)
          <span class="cm-variable-2">andThen</span>(<span class="cm-variable-2">level</span>.<span class="cm-property">status</span>);
        <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
      }
    });
  }
  <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_83gTFxcRTB" href="#p_83gTFxcRTB"></a>An animation can be interrupted by returning <code>false</code> from the function
given to <code>runAnimation</code>. It can be continued by simply calling
<code>runAnimation</code> again.</p>
<p><a class=p_ident id="p_aRwM98cvqb" href="#p_aRwM98cvqb"></a>To communicate the fact that the animation should be intterupted to
the animation function, you can use a variable that both the event
handler and that function have access to.</p>
<p><a class=p_ident id="p_FDlbFLVUQ7" href="#p_FDlbFLVUQ7"></a>When finding a way to unregister the handlers registered by
<code>trackKeys</code>, remember that the <em>exact</em> same function value that was
passed to <code>addEventListener</code> must be passed to <code>removeEventListener</code>
to successfully remove a handler. Thus, the <code>handler</code> function value
created in <code>trackKeys</code> must be available to the code that unregisters
the handlers.</p>
<p><a class=p_ident id="p_mn/dvab7i4" href="#p_mn/dvab7i4"></a>You can add a property to the object returned by <code>trackKeys</code>,
containing either that function value, or a method that handles the
unregistering directly.</p>
</div></div>
<nav>
  <a href="14_event.html" title="previous chapter">⬅</a>
  <a href="index.html" title="cover">⬆</a>
  <a href="16_canvas.html" title="next chapter">➡</a>
</nav>
</article>
