<!doctype html>
<head>
  <meta charset="utf-8">
  <title>Drawing on Canvas :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/node_modules/codemirror/lib/codemirror.js"></script>
  <script src="js/node_modules/codemirror/mode/javascript/javascript.js"></script>
  <script src="js/node_modules/codemirror/mode/css/css.js"></script>
  <script src="js/node_modules/codemirror/mode/xml/xml.js"></script>
  <script src="js/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <script src="js/node_modules/codemirror/addon/edit/matchbrackets.js"></script>
  <script src="js/node_modules/acorn/acorn.js"></script>
  <script src="js/node_modules/acorn/util/walk.js"></script>
  <link rel=stylesheet href="ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 16;var sandboxLoadFiles = ["js/15_game.js", "js/code/game_levels.js", "js/16_canvas.js"];</script>
</head>

<article>
<nav>
  <a href="15_game.html" title="previous chapter">⬅</a>
  <a href="index.html" title="cover">⬆</a>
  <a href="17_http.html" title="next chapter">➡</a>
</nav>

<h1><div class=chap_num>Chapter 16</div>Drawing on Canvas</h1>
<blockquote>
<p><a class=p_ident id="p_ubdp8gf0Gn" href="#p_ubdp8gf0Gn"></a>Drawing is deception</p>
 <footer>M.C. Escher, <cite>cited by Bruno Ernst in The Magic Mirror of M.C. Escher</cite></footer>
</blockquote>
<p><a class=p_ident id="p_lf+BLSKtfd" href="#p_lf+BLSKtfd"></a>Browsers provide several ways to create graphics. The simplest
approach is to use regular DOM elements, and use styles to position
and color them. This can get us quite far, as the previous chapter
showed. By adding partially transparent background images to the
nodes, we can make then look exactly the way we want to. It is even
possible to rotate or skew nodes by using the <code>transform</code> style.</p>
<p><a class=p_ident id="p_4MfzfTYnsB" href="#p_4MfzfTYnsB"></a>But we&#8217;d be using the DOM for something that it wasn&#8217;t originally
designed for. There are things, like drawing a line between arbitrary
points, that are extremely awkward to do with regular HTML elements.</p>
<p><a class=p_ident id="p_ETEHgjW4XZ" href="#p_ETEHgjW4XZ"></a>There are two alternatives. The first is DOM-based, but utilizing
<em>SVG</em>, rather than HTML elements, which you can think of as a
different dialect for describing documents, one that focuses on shapes
rather than text. An SVG document can be embedded inside an HTML
document, but also included through an <code>&lt;img&gt;</code> tag.</p>
<p><a class=p_ident id="p_jhZ3BwOqUW" href="#p_jhZ3BwOqUW"></a>The second alternative is called a <em>canvas</em>. A canvas is a single DOM
node that encapsulates a whole picture. It provides a programming
interface for drawing shapes onto the space taken up by the node. The
main difference between a canvas and an SVG picture is that in SVG,
the original description of the shapes is preserved, so that they can
be moved or resized at any time. Canvas, on the other hand, converts
the shapes to pixels (colored dots on a raster) as soon as they are
drawn, and does not remember what these pixels represent. The only way
to move a shape on a canvas is to clear the canvas (or the area around
the shape) and redraw it with the shape in its new position.</p>
<h2 id="_svg">SVG</h2>
<p><a class=p_ident id="p_E5N5dSPvY7" href="#p_E5N5dSPvY7"></a>This book not go into SVG in detail, but I will briefly try to explain
how it works. At the end of the chapter, I&#8217;ll come back to the
trade-offs that must be considered when deciding which drawing
mechanism is the most appropriate for a given application.</p>
<p><a class=p_ident id="p_VAJSs0B9fT" href="#p_VAJSs0B9fT"></a>This is an HTML document with a simple SVG picture inside of it:</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="svg"><a class=c_ident id="c_9sV17SbXSt" href="#c_9sV17SbXSt"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Normal HTML here.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">svg</span> <span class="cm-attribute">xmlns</span>=<span class="cm-string">"http://www.w3.org/2000/svg"</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">circle</span> <span class="cm-attribute">r</span>=<span class="cm-string">"50"</span> <span class="cm-attribute">cx</span>=<span class="cm-string">"50"</span> <span class="cm-attribute">cy</span>=<span class="cm-string">"50"</span> <span class="cm-attribute">fill</span>=<span class="cm-string">"red"</span><span class="cm-tag cm-bracket">/></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">rect</span> <span class="cm-attribute">x</span>=<span class="cm-string">"120"</span> <span class="cm-attribute">y</span>=<span class="cm-string">"5"</span> <span class="cm-attribute">width</span>=<span class="cm-string">"90"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"90"</span>
        <span class="cm-attribute">stroke</span>=<span class="cm-string">"blue"</span> <span class="cm-attribute">fill</span>=<span class="cm-string">"none"</span><span class="cm-tag cm-bracket">/></span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">svg</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_sJ+IuoXUNA" href="#p_sJ+IuoXUNA"></a>The <code>xmlns</code> attribute changes a node (and its children) to a different
<em>XML namespace</em>. This namespace, identified by a URL, specifies the
dialect that we are currently speaking. The <code>&lt;circle&gt;</code> and <code>&lt;rect&gt;</code>
tags, which do not exist in HTML, do have a meaning in SVG—they draw
shapes, using the style and position specified by their attributes.</p>
<p><a class=p_ident id="p_DcMLpWRkj0" href="#p_DcMLpWRkj0"></a>These tags create DOM elements, just like HTML tags. For example, this
changes the <code>&lt;circle&gt;</code> element to be colored cyan instead:</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="svg"><a class=c_ident id="c_nTTh9qtCeV" href="#c_nTTh9qtCeV"></a><span class="cm-keyword">var</span> <span class="cm-variable">circle</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"circle"</span>);
<span class="cm-variable">circle</span>.<span class="cm-property">setAttribute</span>(<span class="cm-string">"fill"</span>, <span class="cm-string">"cyan"</span>);</pre>
<p><a class=p_ident id="p_7McIVcWiS1" href="#p_7McIVcWiS1"></a>You can even register mouse event handler on such elements.</p>
<h2 id="_the_canvas_element">The canvas element</h2>
<p><a class=p_ident id="p_81TEgZtPp7" href="#p_81TEgZtPp7"></a>Canvas graphics can be drawn onto a <code>&lt;canvas&gt;</code> tag. You can give such
an element <code>width</code> and <code>height</code> attributes to determine its size, in
pixels.</p>
<p><a class=p_ident id="p_oQeTfkBH6v" href="#p_oQeTfkBH6v"></a>A new canvas is empty, meaning it is entirely transparent, and thus
shows up simply as empty space in the document.</p>
<p><a class=p_ident id="p_on1wh4z3I2" href="#p_on1wh4z3I2"></a>The canvas tag is intended to support different styles of drawing. To
get access to an actual drawing interface, we first need to create a
<em>context</em>, which is an object whose methods provide the drawing
interface. There are currently two widely supported drawing styles,
<code>"2d"</code> for two-dimensional graphics, and <code>"webgl"</code> for
three-dimensional graphics through the widely used OpenGL interface.</p>
<p><a class=p_ident id="p_1UFsMGzvch" href="#p_1UFsMGzvch"></a>This book won&#8217;t discuss WebGL. We stick to two dimensions. But if you
are interested in three-dimensional graphics, do look into WebGL. It
provides a very direct interface to modern graphics hardware, and thus
allows you to render even complicated scenes very efficiently—from
JavaScript.</p>
<p><a class=p_ident id="p_GM4b1ASHzf" href="#p_GM4b1ASHzf"></a>A context is created through the <code>getContext</code> method on the <code>&lt;canvas&gt;</code>
element.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_zO7wYMpg7j" href="#c_zO7wYMpg7j"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Before canvas.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"120"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"60"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>After canvas.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">context</span> <span class="cm-operator">=</span> <span class="cm-variable">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">context</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"red"</span>;
  <span class="cm-variable">context</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>, <span class="cm-number">100</span>, <span class="cm-number">50</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_fv4PQSHT32" href="#p_fv4PQSHT32"></a>After creating the context object, the example draws a red rectangle
100 pixels wide and 50 pixels high, with its top left corner at
coordinates <em>10,10</em>.</p>
<p><a class=p_ident id="p_KqVFgjqKgD" href="#p_KqVFgjqKgD"></a>Just like in HTML (and SVG), the coordinate system that the canvas
uses puts <em>0,0</em> at the top left corner, and the positive y axis goes
down from there, so <em>10,10</em> is ten pixels below and to the right of
at corner.</p>
<h2 id="_filling_and_stroking">Filling and stroking</h2>
<p><a class=p_ident id="p_JXUWCLZ5LD" href="#p_JXUWCLZ5LD"></a>In the terminology used by the canvas interface (as well as by SVG),
there are two things that can be done with a shape. It can be either
<em>filled</em>, meaning its area is given a certain color (or pattern), or
it can be <em>stroked</em>, which means a line is drawn along its edge.</p>
<p><a class=p_ident id="p_jXutP8Kp6D" href="#p_jXutP8Kp6D"></a>The <code>fillRect</code> method fills a rectangle. It takes first the x and y
coordinates of the rectangle&#8217;s top left corner, then its width, and
then its height. A similar method, <code>strokeRect</code>, draws the outline of
a rectangle.</p>
<p><a class=p_ident id="p_3jMSv3axea" href="#p_3jMSv3axea"></a>Neither of these methods take any parameters beyond the dimensions of
the rectangle. The way in which the filling or stroking happens is not
determined by an argument to the method (as you might justly expect),
but rather by properties of the drawing context object.</p>
<p><a class=p_ident id="p_qwtIen1h5e" href="#p_qwtIen1h5e"></a>Setting <code>fillStyle</code> changes the way shapes are filled. It can be set
to a string that specifies a color (any color understood by CSS can
also be used here).</p>
<p><a class=p_ident id="p_z2EgIJKmOE" href="#p_z2EgIJKmOE"></a>The <code>strokeStyle</code> property work similarly, but determines the color
used for a stroked line. The width of that line is determined by the
<code>lineWidth</code> property, which may contain any positive number.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_qUCf3DLIeE" href="#c_qUCf3DLIeE"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">strokeStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"blue"</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">strokeRect</span>(<span class="cm-number">5</span>, <span class="cm-number">5</span>, <span class="cm-number">50</span>, <span class="cm-number">50</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-number">5</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">strokeRect</span>(<span class="cm-number">135</span>, <span class="cm-number">5</span>, <span class="cm-number">50</span>, <span class="cm-number">50</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_AIygWrCmAA" href="#p_AIygWrCmAA"></a>When no <code>width</code> or <code>height</code> attributes are specified, the canvas will
get a default width of 300 and height of 150 pixels.</p>
<h2 id="_paths">Paths</h2>
<p><a class=p_ident id="p_aTmbuZIO6P" href="#p_aTmbuZIO6P"></a>A path is a sequence of lines. The 2d canvas interface&#8217;s approach to
describing such a path is rather peculiar. It is done entirely through
side effects.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_zlB23kTDbz" href="#c_zlB23kTDbz"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">y</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>; <span class="cm-variable">y</span> <span class="cm-operator">&lt;</span> <span class="cm-number">100</span>; <span class="cm-variable">y</span> <span class="cm-operator">+=</span> <span class="cm-number">10</span>) {
    <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-variable">y</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">90</span>, <span class="cm-variable">y</span>);
  }
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_bVkIQsme8i" href="#p_bVkIQsme8i"></a>The example creates a path with a number of horizontal line segments,
and then strokes it using the <code>stroke</code> method. Each segment created
with <code>lineTo</code> starts at the path&#8217;s <em>current</em> position, which is the
end of the last segment, unless that position was moved using
<code>moveTo</code>.</p>
<p><a class=p_ident id="p_XmI5jVmo/l" href="#p_XmI5jVmo/l"></a>When filling a path (using the <code>fill</code> method), each shape is filled
separately. A path can contain multiple shapes—each <code>moveTo</code> motion
starts a new one. If the path is not already <em>closed</em> (its start and
end are in different positions), a line is added from its end to its
start, and the shape enclosed by the resulting line is filled.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_Y4QrZmCi4W" href="#c_Y4QrZmCi4W"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">50</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">10</span>, <span class="cm-number">70</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">90</span>, <span class="cm-number">70</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">fill</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_YQG6Oe9ZY9" href="#p_YQG6Oe9ZY9"></a>This draws a filled triangle. Note that only two of the triangle&#8217;s
sides are explicitly drawn. The third, from the bottom right corner
back to the top, is implied, and won&#8217;t be there when we stroke the
path.</p>
<p><a class=p_ident id="p_0LscoyVx/C" href="#p_0LscoyVx/C"></a>The <code>closePath</code> method explicitly closes a path by adding an actual
line segment back to its start. This segment <em>is</em> drawn when stroking
the path.</p>
<h2 id="_curves">Curves</h2>
<p><a class=p_ident id="p_xee0Jzlsic" href="#p_xee0Jzlsic"></a>A path may also contain curved lines. These are, unfortunately, a bit
more involved to draw than straight lines.</p>
<p><a class=p_ident id="p_qdhco6qgn3" href="#p_qdhco6qgn3"></a>The <code>quadraticCurveTo</code> method draws a curve to a given point. To
determine the curvature of the line, it is given a control point as
well as a destination point. You can imagine this control point as
<em>attracting</em> the line, giving it its curve. The line won&#8217;t go through
the control point. Rather, the direction of the line at its start and
end point will be such that it aligns with the line from there to the
control point. The following picture illustrates this:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_aLxDpMt3xQ" href="#c_aLxDpMt3xQ"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">90</span>);
  <span class="cm-comment">// control=(60,10) goal=(90,90)</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">quadraticCurveTo</span>(<span class="cm-number">60</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">90</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">60</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">closePath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_S+iefBW0M9" href="#p_S+iefBW0M9"></a>We draw a quadratic curve from the left to the right, with <em>60,10</em> as
control point, and then draw two line segments, going through that
control point and back to the start of the line. The result somewhat
resembles a Star Trek insignia. You can see the effect of the control
point: the lines leaving the lower corners start off in the direction
of the control point, and then curve towards their target.</p>
<p><a class=p_ident id="p_OsylB59gl1" href="#p_OsylB59gl1"></a>A similar kind of curve is drawn with <code>bezierCurve</code>. Instead of a
single control point, this one has two—one for each end of the line.
Here is a similar sketch to illustrates the behavior of such a curve:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_peL3NEV/UH" href="#c_peL3NEV/UH"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">90</span>);
  <span class="cm-comment">// control1=(10,10) control2=(90,10) goal=(50,90)</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">bezierCurveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">10</span>, <span class="cm-number">50</span>, <span class="cm-number">90</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">90</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">closePath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_UVt0ID9CaV" href="#p_UVt0ID9CaV"></a>The two control points specify the direction at both ends of the curve.
The further they are away from their corresponding point, the more the
curve will “bulge” in that direction.</p>
<p><a class=p_ident id="p_U5Z+65ud3W" href="#p_U5Z+65ud3W"></a>Such curves are unfortunately not very easy to work with—finding the
control points that provide the shape you are looking for can be
difficult. Sometimes you can find a way to compute them, and sometimes
you&#8217;ll just have to find a suitable value by trial and error.</p>
<p><a class=p_ident id="p_hQaggGqaPB" href="#p_hQaggGqaPB"></a>Easier to reason about are <em>arcs</em>—fragments of a circle. The <code>arcTo</code>
method method takes no less than five arguments. The first four act
somewhat like the arguments to <code>quadraticCurveTo</code>—the first two are
a sort of control point, and the second two are the line&#8217;s
destination. The fifth argument provides the radius of the arc. The
method will conceptually take a corner, a line going to the control
point and then the destination point, and round its point so that it
forms part of a circle with the given radius. It then draws this
rounded part, as well as a line from the starting position to the
start of the rounded part.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_jmhrt5PIl+" href="#c_jmhrt5PIl+"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>);
  <span class="cm-comment">// control=(90,10) goal=(90,90) radius=20</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arcTo</span>(<span class="cm-number">90</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">90</span>, <span class="cm-number">20</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>);
  <span class="cm-comment">// control=(90,10) goal=(90,90) radius=80</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arcTo</span>(<span class="cm-number">90</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">90</span>, <span class="cm-number">80</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_+oDzi4kZW+" href="#p_+oDzi4kZW+"></a>The <code>arcTo</code> method will not draw the line from the end of the rounded
part to the goal position, though the word “to” in its name would
suggest it does. You can follow up with a call to <code>lineTo</code> with the
same goal coordinates to add that part of the line.</p>
<p><a class=p_ident id="p_amjPveUnsp" href="#p_amjPveUnsp"></a>To draw a circle, you could use four calls to <code>arcTo</code> (each turning 90
degrees). But the <code>arc</code> method provides a simpler way. It takes a pair
of coordinates for the arc&#8217;s center, a radius, and then a start and
end angle.</p>
<p><a class=p_ident id="p_R0hMJ8VOzu" href="#p_R0hMJ8VOzu"></a>Those last two parameters make it possible to draw only a part of
circle. The angles are measured in radians, not degrees. This means
that a full circle has an angle of 2π (<code>2 * Math.PI</code>, about 6.28). The
angle starts counting at the point to the right of the circle&#8217;s
center, and goes clockwise from there. You can use a start of zero and
an end bigger than 2π (say, 7) to draw a full circle.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_DUIw2Qhi59" href="#c_DUIw2Qhi59"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-comment">// center=(50,50) radius=40 angle=0 to 7</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">50</span>, <span class="cm-number">50</span>, <span class="cm-number">40</span>, <span class="cm-number">0</span>, <span class="cm-number">7</span>);
  <span class="cm-comment">// center=(150,50) radius=40 angle=0 to ½π</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">150</span>, <span class="cm-number">50</span>, <span class="cm-number">40</span>, <span class="cm-number">0</span>, <span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_NhI3gukqbY" href="#p_NhI3gukqbY"></a>The resulting picture contains a line from the left of the full circle
(first call to <code>arc</code>) to the left of the quarter-circle (second call).
Like other path drawing methods, a line drawn with <code>arc</code> is connected
to the previous path segment by default. You&#8217;d have to call <code>moveTo</code>
(or start a new path) if you want to avoid this.</p>
<h2 id="_drawing_a_smooth_line">Drawing a smooth line</h2>
<p><a class=p_ident id="p_Rd++tqzkHn" href="#p_Rd++tqzkHn"></a>Imagine you&#8217;ve just taken a job at EconomiCorp Inc., and your first
assignment is to draw a pie chart of their customer satisfaction
survey results.</p>
<p><a class=p_ident id="p_NOg95U8NVA" href="#p_NOg95U8NVA"></a>The <code>results</code> variable contains an array of objects that represent the
survey responses:</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="pie"><a class=c_ident id="c_Wu/ylZx+Sb" href="#c_Wu/ylZx+Sb"></a><span class="cm-keyword">var</span> <span class="cm-variable">results</span> <span class="cm-operator">=</span> [
  {<span class="cm-property">name</span>: <span class="cm-string">"Satisfied"</span>, <span class="cm-property">count</span>: <span class="cm-number">1043</span>, <span class="cm-property">color</span>: <span class="cm-string">"lightblue"</span>},
  {<span class="cm-property">name</span>: <span class="cm-string">"Neutral"</span>, <span class="cm-property">count</span>: <span class="cm-number">563</span>, <span class="cm-property">color</span>: <span class="cm-string">"lightgreen"</span>},
  {<span class="cm-property">name</span>: <span class="cm-string">"Unsatisfied"</span>, <span class="cm-property">count</span>: <span class="cm-number">510</span>, <span class="cm-property">color</span>: <span class="cm-string">"pink"</span>},
  {<span class="cm-property">name</span>: <span class="cm-string">"No comment"</span>, <span class="cm-property">count</span>: <span class="cm-number">175</span>, <span class="cm-property">color</span>: <span class="cm-string">"silver"</span>}
];</pre>
<p><a class=p_ident id="p_P3SJQbINGf" href="#p_P3SJQbINGf"></a>To draw a pie chart, we draw a number of pie slices, made up of an
arc, and a pair of lines to the center of that arc. We can compute the
angle taken up by each arc by dividing a full circle (2π) by the total
number of responses, and then multiplying that number (the angle per
response) by the amount of people that picked a given choice.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="pie"><a class=c_ident id="c_605WiwvqXC" href="#c_605WiwvqXC"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"200"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"200"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">total</span> <span class="cm-operator">=</span> <span class="cm-variable">results</span>.<span class="cm-property">reduce</span>(<span class="cm-keyword">function</span>(<span class="cm-def">sum</span>, <span class="cm-def">choice</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">sum</span> <span class="cm-operator">+</span> <span class="cm-variable-2">choice</span>.<span class="cm-property">count</span>;
  }, <span class="cm-number">0</span>);
  <span class="cm-comment">// Start at the top</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">currentAngle</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-variable">results</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">result</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">sliceAngle</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">count</span> <span class="cm-operator">/</span> <span class="cm-variable">total</span>) <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
    <span class="cm-comment">// center=100,100, radius=100</span>
    <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">100</span>, <span class="cm-number">100</span>, <span class="cm-number">100</span>,
    <span class="cm-comment">// from current angle, clockwise by slice's angle</span>
           <span class="cm-variable">currentAngle</span>, <span class="cm-variable">currentAngle</span> <span class="cm-operator">+</span> <span class="cm-variable-2">sliceAngle</span>);
    <span class="cm-variable">currentAngle</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">sliceAngle</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">100</span>, <span class="cm-number">100</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">result</span>.<span class="cm-property">color</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">fill</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_XUuzVtzkRa" href="#p_XUuzVtzkRa"></a>A pie chart that doesn&#8217;t tell us what the slices mean is not very
helpful. We would like to have a way to draw text to the canvas.</p>
<h2 id="_text">Text</h2>
<p><a class=p_ident id="p_dadMCfID0v" href="#p_dadMCfID0v"></a>A 2d canvas drawing context provides the methods <code>fillText</code> and
<code>strokeText</code>. The latter can be used for outlining letters, but
usually <code>fillText</code> is what you want. It will fill the given text with
the current <code>fillColor</code>.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_F/afe4sx+7" href="#c_F/afe4sx+7"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">font</span> <span class="cm-operator">=</span> <span class="cm-string">"28px Georgia"</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"fuchsia"</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">fillText</span>(<span class="cm-string">"I can draw text, too!"</span>, <span class="cm-number">10</span>, <span class="cm-number">50</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_bHdWBO9oym" href="#p_bHdWBO9oym"></a>The size, style, and font of the text can be specified using the
<code>font</code> property. The example gives just a font size and family name.
You can add <code>italic</code> or <code>bold</code> to the start of the string to select a
style.</p>
<p><a class=p_ident id="p_3LlDU7wt/M" href="#p_3LlDU7wt/M"></a>The last two arguments to <code>fillText</code> (and <code>strokeText</code>) provide the
position at which the font is drawn. By default, they indicate the
position of the start of the text&#8217;s alphabetic baseline (the line on
which the letters “stand”, not counting hanging parts in letters like
“j” or “p”). The horizontal position can be changed by setting the
<code>textAlign</code> property to <code>"end"</code> or <code>"center"</code>, the vertical position
by setting <code>textBaseline</code> to <code>"top"</code>, <code>"middle"</code>, or <code>"bottom"</code>.</p>
<p><a class=p_ident id="p_/4NicYFaZd" href="#p_/4NicYFaZd"></a>We will come back to our pie chart, and the problem of labeling the
slices, in the exercises at the end of the chapter.</p>
<h2 id="_images">Images</h2>
<p><a class=p_ident id="p_y7aK+8CMcM" href="#p_y7aK+8CMcM"></a>In computer graphics, a distinction is often made between <em>vector</em>
graphics and <em>bitmap</em> graphics. The first is what we have been doing
so far in this chapter—specifying a picture by giving a logical
description of shapes. Bitmap graphics, on the other hand, don&#8217;t
specify actual shapes but rather work with pixel data (rasters of
colored dots).</p>
<p><a class=p_ident id="p_qlIKv8QV+7" href="#p_qlIKv8QV+7"></a>The <code>drawImage</code> method allows us to draw pixel data onto a canvas.
This pixel data can originate from an <code>&lt;img&gt;</code> element or from another
canvas (neither have to be visible in the actual document). The
example below creates a detached <code>&lt;img&gt;</code> element and loads an image
file into it. But it can not immediately start drawing from this
picture, because the browser may not have fetched it yet. To deal with
this, we register a <code>"load"</code> event handler, and do the drawing after
the image has loaded.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_t4DLmjY6Qj" href="#c_t4DLmjY6Qj"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">img</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable">img</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/hat.png"</span>;
  <span class="cm-variable">img</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-number">200</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">+=</span> <span class="cm-number">30</span>)
      <span class="cm-variable">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">img</span>, <span class="cm-variable-2">x</span>, <span class="cm-number">10</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_Jc1BmrX2Vh" href="#p_Jc1BmrX2Vh"></a>By default, <code>drawImage</code> will draw the image at its original size. You
can give it two additional arguments to determine the width and height
with which it is drawn.</p>
<p><a class=p_ident id="p_/bLIqvw4R4" href="#p_/bLIqvw4R4"></a>When <code>drawImage</code> is given <em>nine</em> arguments, it can be used to draw
only a fragment of an image. The second to fifth argument indicate the
rectangle (x, y, width, and height) in the source image that should be
copied, and the sixth to ninth argument give the rectangle (on the
canvas) into which it should be copied.</p>
<p><a class=p_ident id="p_xKlo8wmmgJ" href="#p_xKlo8wmmgJ"></a>This can be used to pack multiple <em>sprites</em> (image elements) into a
single image file, and then copy out the part you need. For example,
we have this picture containing a game character in multiple poses.</p>
<div class="image">
  <img src="img/player.png" alt="Various poses of a game character">
</div>
<p><a class=p_ident id="p_whrzvWBuQe" href="#p_whrzvWBuQe"></a>If we alternate which pose we draw, we can show an animation that
looks like a walking character.</p>
<p><a class=p_ident id="p_GpxeRe/xwW" href="#p_GpxeRe/xwW"></a>To animate the picture on a canvas, the <code>clearRect</code> method is useful.
It resembles <code>fillRect</code>, but instead of coloring the rectangle, it
resets it back to transparent.</p>
<p><a class=p_ident id="p_VcrdBA3T8z" href="#p_VcrdBA3T8z"></a>We know that each <em>sprite</em>, each sub-picture, is 16 pixels wide and 30
pixels high. The code below loads the image, and then sets up an
interval (repeated timer) to draw the next frame.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_SOo1UwJuwI" href="#c_SOo1UwJuwI"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">img</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable">img</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/player.png"</span>;
  <span class="cm-keyword">var</span> <span class="cm-variable">spriteW</span> <span class="cm-operator">=</span> <span class="cm-number">16</span>, <span class="cm-variable">spriteH</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
  <span class="cm-variable">img</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">cycle</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
    <span class="cm-variable">setInterval</span>(<span class="cm-keyword">function</span>() {
      <span class="cm-variable">cx</span>.<span class="cm-property">clearRect</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>);
      <span class="cm-variable">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">img</span>,
                   <span class="cm-comment">// source rectangle</span>
                   <span class="cm-variable-2">cycle</span> <span class="cm-operator">*</span> <span class="cm-variable">spriteW</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>,
                   <span class="cm-comment">// destination rectangle</span>
                   <span class="cm-number">0</span>,               <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>);
      <span class="cm-variable-2">cycle</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">cycle</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>) <span class="cm-operator">%</span> <span class="cm-number">8</span>;
    }, <span class="cm-number">120</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_FwoYTH1Pg7" href="#p_FwoYTH1Pg7"></a>The <code>cycle</code> variable tracks our position in the animation. Each frame,
it is incremented and then clipped back to the 0 to 7 range by using
the remainder operator. This variable is then used to compute the x
coordinate that the sprite for the current posture has in the picture.</p>
<h2 id="_transformation">Transformation</h2>
<p><a class=p_ident id="p_b00lbwHiev" href="#p_b00lbwHiev"></a>But what if we want our character to walk to the left instead of to
the right? We could add another set of sprites, of course. But we can
also instruct the canvas to draw the picture the other way round.</p>
<p><a class=p_ident id="p_JnX4LFnuKL" href="#p_JnX4LFnuKL"></a>Calling the <code>scale</code> method will cause anything drawn after it to be
scaled. It takes two parameters, one to set a horizontal scale and one
to set a vertical scale.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_vIKZksVzWu" href="#c_vIKZksVzWu"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">scale</span>(<span class="cm-number">3</span>, <span class="cm-number">.5</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">50</span>, <span class="cm-number">50</span>, <span class="cm-number">40</span>, <span class="cm-number">0</span>, <span class="cm-number">7</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-number">3</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_u+8/LLl96H" href="#p_u+8/LLl96H"></a>Scaling will cause everything about the drawn image, including the
line width, to be stretched out or squeezed together as specified.
Scaling by a negative amount will flip the picture around. The
flipping happens around point <em>0,0</em>, which means that it will also
flip the direction of the coordinate system. When a horizontal scaling
of -1 is applied, a shape drawn at x position 100 will end up at what
used to be position -100.</p>
<p><a class=p_ident id="p_/xZXbIyydV" href="#p_/xZXbIyydV"></a>So to turn a picture around, we can not simply add <code>cx.scale(-1, 1)</code>
before the call to <code>drawImage</code>, since that would move our picture
outside of the canvas, where it won&#8217;t be visible.</p>
<p><a class=p_ident id="p_Y6LMkxSEpw" href="#p_Y6LMkxSEpw"></a>One way to fix this is by adjusting the coordinates given to
<code>drawImage</code> to compensate for this (by drawing it at x position -50
instead of 0). Another way, which requires less changes to other code,
is to adjust the axis around which the scaling happens.</p>
<p><a class=p_ident id="p_LbiF7s9yt4" href="#p_LbiF7s9yt4"></a>There are several other methods, besides <code>scale</code> that influence the
coordinate system for a canvas. It can be rotated with the <code>rotate</code>
method, and moved with the <code>translate</code> method. The interesting— and
confusing—thing is that these transformations <em>stack</em>, meaning that
each one happens relative to the previous transformations.</p>
<p><a class=p_ident id="p_mkNUtuNxcG" href="#p_mkNUtuNxcG"></a>So if we translate (move) by 10 horizontal pixels twice, everything
will be drawn 20 pixels to the right. If we first move the center of
the coordinate system to <em>50,50</em> and then rotate by 20 degrees (0.1π
in radians), that rotation will happen around point <em>50,50</em>.</p>
<div class="image">
  <img src="img/transform.svg" alt="Stacking transformations">
</div>
<p><a class=p_ident id="p_DDGbuau9f3" href="#p_DDGbuau9f3"></a>But if, instead, we first rotated by 20 degrees, and then translated
by <em>50,50</em>, the translation will happen in the rotated coordinate
system, and thus produce a different orientation. The order in which
transformations are applied matters.</p>
<p><a class=p_ident id="p_9a1O8aEtUA" href="#p_9a1O8aEtUA"></a>To flip a picture around the vertical line at a given x position, we
can do the following:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_81ITeF67ab" href="#c_81ITeF67ab"></a><span class="cm-keyword">function</span> <span class="cm-variable">flipHorizontally</span>(<span class="cm-def">context</span>, <span class="cm-def">around</span>) {
  <span class="cm-variable-2">context</span>.<span class="cm-property">translate</span>(<span class="cm-variable-2">around</span>, <span class="cm-number">0</span>);
  <span class="cm-variable-2">context</span>.<span class="cm-property">scale</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>, <span class="cm-number">1</span>);
  <span class="cm-variable-2">context</span>.<span class="cm-property">translate</span>(<span class="cm-operator">-</span><span class="cm-variable-2">around</span>, <span class="cm-number">0</span>);
}</pre>
<p><a class=p_ident id="p_//KR67+UGF" href="#p_//KR67+UGF"></a>We first move the y axis to where we want our mirror to be, then apply
the mirroring, and finally move the y axis back to its proper place in
the mirrored universe. The picture below tries to explain why this
works.</p>
<div class="image">
  <img src="img/mirror.svg" alt="Mirroring around a vertical line">
</div>
<p><a class=p_ident id="p_AGahdKv9Zv" href="#p_AGahdKv9Zv"></a>This shows the coordinate systems, before and after mirroring in the
central line. If we draw a triangle at a positive x position, it
would, by default, be in the place where triangle 1 is. A call to
<code>flipHorizontally</code> first does a translation to the right, which gets
us to triangle 2. It then scales, flipping the triangle back to
position 3. This is not where it should be, if it were mirrored in the
given line. The second <code>translate</code> call fixes this—it “cancels” the
initial translation, and makes triangle 4 appear exactly where it
should.</p>
<p><a class=p_ident id="p_akkrexzSeV" href="#p_akkrexzSeV"></a>We can now draw a mirrored character at position <em>100,0</em> by flipping
the world around the character&#8217;s vertical center:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_j4H/kxvEFV" href="#c_j4H/kxvEFV"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">img</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable">img</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/player.png"</span>;
  <span class="cm-keyword">var</span> <span class="cm-variable">spriteW</span> <span class="cm-operator">=</span> <span class="cm-number">16</span>, <span class="cm-variable">spriteH</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
  <span class="cm-variable">img</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">flipHorizontally</span>(<span class="cm-variable">cx</span>, <span class="cm-number">100</span> <span class="cm-operator">+</span> <span class="cm-variable">spriteW</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">img</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>,
                 <span class="cm-number">100</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<h2 id="_storing_and_clearing_transformations">Storing and clearing transformations</h2>
<p><a class=p_ident id="p_Az5iI5GbrT" href="#p_Az5iI5GbrT"></a>Transformations stick around. Everything else we draw after drawing
that mirrored character would also be mirrored. That might be a
problem.</p>
<p><a class=p_ident id="p_2w0V4tGzbz" href="#p_2w0V4tGzbz"></a>The <code>resetTransform</code> method (which takes no arguments) clears the
canvas’ transformations entirely. It is also possible to save the
current transformation, do some drawing and transforming, and then
restore the old transformation. This is usually the proper thing to do
for a function that needs to temporarily transform the coordinate
system: first save whatever the code that called the function was
using, then do its thing (on top of the existing transformation), and
then revert to what it started with.</p>
<p><a class=p_ident id="p_65OomGfaeV" href="#p_65OomGfaeV"></a>The <code>save</code> and <code>restore</code> methods on the 2d canvas context perform this
kind of transformation tracking. They conceptually maintain a stack of
transformation states. When you call <code>save</code>, the current state is
pushed onto the stack, and when you call <code>restore</code>, the state on top
of the stack is taken off, and used as the context&#8217;s current
transformation.</p>
<p><a class=p_ident id="p_CX+bUECYKA" href="#p_CX+bUECYKA"></a>The example below illustrates what you can do with a function that
changes the transformation and then calls another function (in this
case itself), which continues drawing with the given transformation.</p>
<p><a class=p_ident id="p_aJD2IPkdOy" href="#p_aJD2IPkdOy"></a>The <code>branch</code> function draws a tree-like shape by first drawing a line,
and then moving the coordinate system to the end of the line and
calling itself twice, first rotated to the left, and then rotated to
the right. Every call reduces the length of the branch drawn, and the
recursion stops when the length drops below 8.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_IcgOLJ7+U4" href="#c_IcgOLJ7+U4"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"600"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"300"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">function</span> <span class="cm-variable">branch</span>(<span class="cm-def">length</span>, <span class="cm-def">angle</span>, <span class="cm-def">scale</span>) {
    <span class="cm-variable">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-variable-2">length</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">8</span>) <span class="cm-keyword">return</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">save</span>();
    <span class="cm-variable">cx</span>.<span class="cm-property">translate</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">length</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">rotate</span>(<span class="cm-operator">-</span><span class="cm-variable-2">angle</span>);
    <span class="cm-variable">branch</span>(<span class="cm-variable-2">length</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">angle</span>, <span class="cm-variable-2">scale</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">rotate</span>(<span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable-2">angle</span>);
    <span class="cm-variable">branch</span>(<span class="cm-variable-2">length</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">angle</span>, <span class="cm-variable-2">scale</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">restore</span>();
  }
  <span class="cm-variable">cx</span>.<span class="cm-property">translate</span>(<span class="cm-number">300</span>, <span class="cm-number">0</span>);
  <span class="cm-variable">branch</span>(<span class="cm-number">60</span>, <span class="cm-number">0.5</span>, <span class="cm-number">0.8</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_Fr9r9ZmPHu" href="#p_Fr9r9ZmPHu"></a>If the calls to <code>save</code> and <code>restore</code> were not there, the second
recursive call to <code>branch</code> would end up with the position and rotation
created by the first call—it would not be connected to the current
branch, but rather to the innermost, rightmost branch drawn by the first
call. The resulting shape might also be interesting, but it is
definitely not a tree.</p>
<h2 id="_back_to_the_game">Back to the game</h2>
<p><a class=p_ident id="p_v/iifj4dhd" href="#p_v/iifj4dhd"></a>We now know enough about canvas drawing to start working on the
canvas-based display system for the game from the last chapter. The
new display will no longer be showing just colored boxes. Instead,
we&#8217;ll use <code>drawImage</code> to draw the game&#8217;s elements.</p>
<p><a class=p_ident id="p_YquFT6qUZe" href="#p_YquFT6qUZe"></a>We must define an object type <code>CanvasDisplay</code>, supporting the same
interface as <code>DOMDisplay</code> from Chapter 15 (methods <code>drawFrame</code> and
<code>clear</code>).</p>
<p><a class=p_ident id="p_H/XEh6pFg7" href="#p_H/XEh6pFg7"></a>This object keeps a little more information that <code>DOMDisplay</code>. Rather
than using the scroll position of its DOM element, it tracks its own view
port, which tells us what part of the level we are currently looking
at. It also tracks time, and uses that to decide which animation frame
to use. And finally, it keeps a <code>flipPlayer</code> property, so that even
when the player is standing still, they keep facing the direction they
last moved in.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class=c_ident id="c_tLZOYVAY+T" href="#c_tLZOYVAY+T"></a><span class="cm-keyword">function</span> <span class="cm-variable">CanvasDisplay</span>(<span class="cm-def">parent</span>, <span class="cm-def">level</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"canvas"</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-number">600</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-number">450</span>;
  <span class="cm-variable-2">parent</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);

  <span class="cm-keyword">this</span>.<span class="cm-property">level</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">animationTime</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">flipPlayer</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span> <span class="cm-operator">=</span> {
    <span class="cm-property">left</span>: <span class="cm-number">0</span>,
    <span class="cm-property">top</span>: <span class="cm-number">0</span>,
    <span class="cm-property">width</span>: <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">/</span> <span class="cm-variable">scale</span>,
    <span class="cm-property">height</span>: <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">/</span> <span class="cm-variable">scale</span>
  };

  <span class="cm-keyword">this</span>.<span class="cm-property">drawFrame</span>(<span class="cm-number">0</span>);
}

<span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">clear</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">removeChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>);
};</pre>
<p><a class=p_ident id="p_O1Tlv8n42e" href="#p_O1Tlv8n42e"></a>The <code>animationTime</code> counter is the reason we passed the step size to
<code>drawFrame</code> in Chapter 15, even though <code>DOMDisplay</code> does not use it.
Our new <code>drawFrame</code> function uses it to keep track of the time the
game has been running (in seconds).</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class=c_ident id="c_L5SVcjdikr" href="#c_L5SVcjdikr"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawFrame</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">animationTime</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">updateViewport</span>();
  <span class="cm-keyword">this</span>.<span class="cm-property">clearDisplay</span>();
  <span class="cm-keyword">this</span>.<span class="cm-property">drawBackground</span>();
  <span class="cm-keyword">this</span>.<span class="cm-property">drawActors</span>();
};</pre>
<p><a class=p_ident id="p_H6FlOK7ajO" href="#p_H6FlOK7ajO"></a>Other than that, the method updates the viewport for the current
player position, clears the whole canvas, and draws the background and
actors onto that. Note that this is different from the approach in
Chapter 15, where we drew the background once and scrolled the
wrapping DOM element to move it.</p>
<p><a class=p_ident id="p_sX9ENmCEO9" href="#p_sX9ENmCEO9"></a>Because shapes on a canvas are just pixels, after we draw them, there
is no way to move them (or remove them). In most cases, the only way
to update a canvas display is to clear it and redraw the scene.</p>
<p><a class=p_ident id="p_Kn4mJDmduk" href="#p_Kn4mJDmduk"></a>The <code>updateViewport</code> method is very similar to <code>DOMDisplay</code>'s
<code>scrollPlayerIntoView</code> method. It checks whether the player is too
close to the edge of the screen, and moves the viewport when this is
the case.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class=c_ident id="c_1+a5sNVyU4" href="#c_1+a5sNVyU4"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">updateViewport</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">view</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>, <span class="cm-def">margin</span> <span class="cm-operator">=</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span> <span class="cm-operator">/</span> <span class="cm-number">3</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">player</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">center</span> <span class="cm-operator">=</span> <span class="cm-variable-2">player</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">player</span>.<span class="cm-property">size</span>.<span class="cm-property">times</span>(<span class="cm-number">0.5</span>));

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">></span> <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span>,
                         <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">width</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">></span> <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span>,
                        <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">height</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span>);
};</pre>
<p><a class=p_ident id="p_qSUMwlAFeW" href="#p_qSUMwlAFeW"></a>The calls to <code>Math.max</code> and <code>Math.min</code> are used to ensure that the
viewport does not end up showing space outside of the level.
<code>Math.max(x, 0)</code> has the effect of ensuring the resulting number is
not less than zero. <code>Math.min</code>, similarly, ensures a value stays below
a given bound.</p>
<p><a class=p_ident id="p_uxQ4EAtiQh" href="#p_uxQ4EAtiQh"></a>When clearing the display, we&#8217;ll use a slightly different color
depending on whether the game is won (brighter) or lost (darker).</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class=c_ident id="c_+6vcI+axYW" href="#c_+6vcI+axYW"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">clearDisplay</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">"won"</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"#44bfff"</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"#2c88d6"</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"#34a6fb"</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>,
                   <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span>, <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span>);
};</pre>
<p><a class=p_ident id="p_TjOnlogmqf" href="#p_TjOnlogmqf"></a>To draw the background, we run through the tiles that are visible in
the current viewport, using the same trick used in <code>obstacleAt</code> in the
previous chapter.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class=c_ident id="c_wL23AkcIa0" href="#c_wL23AkcIa0"></a><span class="cm-keyword">var</span> <span class="cm-variable">otherSprites</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
<span class="cm-variable">otherSprites</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/sprites.png"</span>;

<span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawBackground</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">view</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">xStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">left</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">xEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">top</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span>);

  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">yStart</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">yEnd</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">xStart</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">xEnd</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">tile</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">grid</span>[<span class="cm-variable-2">y</span>][<span class="cm-variable-2">x</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">tile</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span>) <span class="cm-keyword">continue</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">screenX</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">x</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">left</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">screenY</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">y</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">top</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">tilePos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">tile</span> <span class="cm-operator">==</span> <span class="cm-string">"lava"</span> <span class="cm-operator">?</span> <span class="cm-variable">scale</span> : <span class="cm-number">0</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">otherSprites</span>,
                        <span class="cm-variable-2">tilePos</span>,       <span class="cm-number">0</span>, <span class="cm-variable">scale</span>, <span class="cm-variable">scale</span>,
                        <span class="cm-variable-2">screenX</span>, <span class="cm-variable-2">screenY</span>, <span class="cm-variable">scale</span>, <span class="cm-variable">scale</span>);
    }
  }
};</pre>
<p><a class=p_ident id="p_exCLyNQQL6" href="#p_exCLyNQQL6"></a>Tiles that are not empty (null) are drawn with <code>drawImage</code>. The
<code>otherSprites</code> image contains the pictures used for the elements that
are not the player. It contains, from left to right, the wall tile,
the lava tile, and then the sprite for a coin.</p>
<div class="image">
  <img src="img/sprites_background.png" alt="Sprites for our game">
</div>
<p><a class=p_ident id="p_6kRyf99OAr" href="#p_6kRyf99OAr"></a>Background tiles are 20 by 20 pixels, since we will use the same scale
that we used in <code>DOMDisplay</code>. Thus, the offset for lava tiles is 20
(the value of the <code>scale</code> variable), and the offset for walls is zero.</p>
<p><a class=p_ident id="p_9eYTJjo9jj" href="#p_9eYTJjo9jj"></a>We do not bother waiting for the sprite image to load in this program.
Calling <code>drawImage</code> with an image that hasn&#8217;t been loaded yet will
simply do nothing. Thus, we might fail to draw the game properly for
the first few frames, while the image is still loading, but that is
not a serious problem. Since we keep updating the screen, the correct
scene will appear as soon as the loading finishes.</p>
<p><a class=p_ident id="p_C68fKINp+O" href="#p_C68fKINp+O"></a>The walking character we used before will be used to represent the
player. The code that draws it needs to pick the right sprite and
direction based on the player&#8217;s current motion. When the player is
standing still, we draw the leftmost sprite. During jumps (when the
vertical speed is not zero), we use the rightmost sprite. When
walking, we cycle through the first 8 sprites based on the display&#8217;s
<code>animationTime</code> property. This is measured in seconds, and we want to
switch frames twelve times per second, so the time is multiplied by 12
first.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class=c_ident id="c_eWx45Y4G+7" href="#c_eWx45Y4G+7"></a><span class="cm-keyword">var</span> <span class="cm-variable">playerSprites</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
<span class="cm-variable">playerSprites</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/player.png"</span>;

<span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawPlayer</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">x</span>, <span class="cm-def">y</span>, <span class="cm-def">width</span>,
                                              <span class="cm-def">height</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">sprite</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>, <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">player</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">flipPlayer</span> <span class="cm-operator">=</span> <span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>;

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span>)
    <span class="cm-variable-2">sprite</span> <span class="cm-operator">=</span> <span class="cm-number">8</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span>)
    <span class="cm-variable-2">sprite</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-keyword">this</span>.<span class="cm-property">animationTime</span> <span class="cm-operator">*</span> <span class="cm-number">12</span>) <span class="cm-operator">%</span> <span class="cm-number">8</span>;

  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">flipPlayer</span>)
    <span class="cm-variable">flipHorizontally</span>(<span class="cm-keyword">this</span>.<span class="cm-property">cx</span>, <span class="cm-variable-2">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">width</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>);

  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">playerSprites</span>,
                    <span class="cm-variable-2">sprite</span> <span class="cm-operator">*</span> <span class="cm-variable-2">width</span>, <span class="cm-number">0</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>,
                    <span class="cm-variable-2">x</span>,              <span class="cm-variable-2">y</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>);

  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">flipPlayer</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">resetTransform</span>();
};</pre>
<p><a class=p_ident id="p_fppAQk4df2" href="#p_fppAQk4df2"></a>We use <code>resetTransform</code> instead of <code>save</code> and <code>restore</code>, because our
drawing system will not use transformations in any other places, and
thus there is no transformation to save.</p>
<p><a class=p_ident id="p_pDMUBSE5P1" href="#p_pDMUBSE5P1"></a>The function above is called by <code>drawActors</code>, which is responsible for
drawing the all the actors in the game.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class=c_ident id="c_njavBBDcMN" href="#c_njavBBDcMN"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawActors</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">actors</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">-</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>.<span class="cm-property">left</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">-</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>.<span class="cm-property">top</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"player"</span>) {
      <span class="cm-keyword">this</span>.<span class="cm-property">drawPlayer</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>);
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">var</span> <span class="cm-def">tile</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"coin"</span> <span class="cm-operator">?</span> <span class="cm-number">2</span> : <span class="cm-number">1</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">otherSprites</span>,
                        <span class="cm-variable-2">tile</span>, <span class="cm-number">0</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>,
                        <span class="cm-variable-2">x</span>,    <span class="cm-variable-2">y</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>);
    }
  }, <span class="cm-keyword">this</span>);
};</pre>
<p><a class=p_ident id="p_PD+LPXwCgk" href="#p_PD+LPXwCgk"></a>When drawing something that is not the player, we look at its type to
find the offset of the correct sprite. The lava tile is found at
offset 20, and the coin sprite at 40 (two times <code>scale</code>).</p>
<p><a class=p_ident id="p_e6Z9O4bib+" href="#p_e6Z9O4bib+"></a>We have to subtract the viewport&#8217;s position when computing the actor&#8217;s
position, since <em>0,0</em> on our canvas corresponds to the top left of the
viewport, not the top left of the level. We could also have used
<code>translate</code> for this. Either way works.</p>
<p><a class=p_ident id="p_4VReSkKraV" href="#p_4VReSkKraV"></a>The tiny document below plugs the new display into <code>runGame</code>:</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="game" data-focus="true"><a class=c_ident id="c_3+gL7ESOoQ" href="#c_3+gL7ESOoQ"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
    <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">CanvasDisplay</span>);
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">></span></pre>
<h2 id="_choosing_a_graphics_interface">Choosing a graphics interface</h2>
<p><a class=p_ident id="p_BZXn4cWyux" href="#p_BZXn4cWyux"></a>Any time you want to generate graphics in the browser, you must choose
between plain HTML, SVG, and canvas. There is no single <em>best</em>
approach that works in all situations. Each option has strengths and
weaknesses.</p>
<p><a class=p_ident id="p_O7BQaYbnwn" href="#p_O7BQaYbnwn"></a>Plain HTML has the advantage of being simple. It also integrates well
with text. Both SVG and canvas allow you to draw text, but won&#8217;t help
with positioning that text, or wrapping it when it takes up more than
one line. In an HTML-based picture, it is very easy to include blocks
of text.</p>
<p><a class=p_ident id="p_6uH6l730WJ" href="#p_6uH6l730WJ"></a>SVG can be used to produce crisp graphics that look good at any zoom
level. It is more difficult to use than plain HTML, but also much more
powerful.</p>
<p><a class=p_ident id="p_0BinMAWIpY" href="#p_0BinMAWIpY"></a>Both SVG and HTML build up a data structure (the DOM) that represents
the picture. This makes it possible to modify elements they are drawn.
If you need to repeatedly change a small part of a big picture, in
response to what the user is doing or as part of an animation, doing
it in canvas can be needlessly expensive. The DOM also allows us to
register mouse event handlers on every element in the picture (even on
shapes drawn with SVG). This can not be done with canvas.</p>
<p><a class=p_ident id="p_KIE7ssJRFb" href="#p_KIE7ssJRFb"></a>But canvas’ pixel-oriented approach can be an advantage when drawing a
huge amount of tiny elements. The fact that it does not build up a
data structure, but only repeatedly draws onto the same pixel surface,
can make it faster in situations like that.</p>
<p><a class=p_ident id="p_6P4A05RVAk" href="#p_6P4A05RVAk"></a>There are also effects, such as rendering a scene one pixel at a time
(for example with a ray tracer), or post-processing an image with
JavaScript (blurring or distorting it) that can only be realistically
handled by a pixel-based technique.</p>
<p><a class=p_ident id="p_lecWO5A8ae" href="#p_lecWO5A8ae"></a>In some cases, it is worthwhile to combine several of these
techniques. For example, drawing a graph with SVG or canvas, but
showing textual information, when the user clicks or hovers over an
element, by positioning an HTML element on top of the picture.</p>
<p><a class=p_ident id="p_WwxFg3eRcd" href="#p_WwxFg3eRcd"></a>For non-demanding applications, it really does not matter much which
interface you choose. The second display we built for our game in this
chapter could have been implemented using any of these thee graphics
technologies. It does not need to draw text, handle mouse interaction,
or work with an extraordinarily large amount of elements.</p>
<h2 id="_summary">Summary</h2>
<p><a class=p_ident id="p_tJH36yWkVt" href="#p_tJH36yWkVt"></a>In this chapter, we discussed techniques for drawing graphics in the
browser, focusing on the <code>&lt;canvas&gt;</code> element.</p>
<p><a class=p_ident id="p_zTR1kU1R2F" href="#p_zTR1kU1R2F"></a>A canvas node represents an area in a document that our program may
draw on. This drawing is done through a drawing context object,
created with the <code>getContext</code> method.</p>
<p><a class=p_ident id="p_g/nbohWmlm" href="#p_g/nbohWmlm"></a>The 2d drawing interface allows us to fill and stroke various shapes.
The way shapes are filled is determined by the context&#8217;s <code>fillStyle</code>
property. The way lines are drawn is controlled by the <code>strokeStyle</code>
and <code>lineWidth</code> properties.</p>
<p><a class=p_ident id="p_p9lwBrZeDB" href="#p_p9lwBrZeDB"></a>Rectangles and pieces of text can be drawn with a single method call
(<code>fillRect</code>, and <code>strokeRect</code>, or <code>fillText</code> and <code>strokeText</code> for
text). To create more complicated shapes, we must first build up a
path.</p>
<p><a class=p_ident id="p_+WESqzV0sH" href="#p_+WESqzV0sH"></a>Calling <code>beginPath</code> starts a new path. A number of other methods add
lines and curves to the current path, for example <code>lineTo</code> can be used
to add a straight line. When a path is finished, it can be filled with
the <code>fill</code> method or stroked with the <code>stroke</code> method.</p>
<p><a class=p_ident id="p_fNYiGRtSKj" href="#p_fNYiGRtSKj"></a>Moving pixels from an image or another canvas onto our canvas is done
with the <code>drawImage</code> method. By default, this method draws the whole
source image, but by giving it more parameters it scan be made to copy
out a specific area. We used this for our game, by copying individual
postures of the game character out of an image that contained many
such postures.</p>
<p><a class=p_ident id="p_ooz2R9pXHq" href="#p_ooz2R9pXHq"></a>To draw a shape in multiple orientations, transformations can be used.
A 2d drawing context has a current transformation that can be changed
with the <code>translate</code>, <code>scale</code>, and <code>rotate</code> methods. These will affect
all subsequent drawing operations, until the transformation is reset
with <code>resetTransform</code>.</p>
<p><a class=p_ident id="p_CiZHyGysLU" href="#p_CiZHyGysLU"></a>When drawing an animation onto a canvas, it the <code>clearRect</code> method can
be used to clear a part of the canvas, before redrawing it.</p>
<h2 id="_exercises">Exercises</h2>
<h3 id="_shapes">Shapes</h3>
<p><a class=p_ident id="p_ML2Sk/PrfT" href="#p_ML2Sk/PrfT"></a>Write a program that draws shapes resembling the following, next to
each other on a canvas:</p>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
A parallelogram (a rectangle that is wider on one side).
</p>
</li>
<li>
<p>
A red diamond (a rectangle rotated 45 degrees or ¼π radians).
</p>
</li>
<li>
<p>
A zigzagging line.
</p>
</li>
<li>
<p>
A spiral made up of 100 straight line segments.
</p>
</li>
<li>
<p>
A yellow star.
</p>
</li>
</ol></div>
<div class="image">
  <img src="img/exercise_shapes.png" alt="The shapes to draw">
</div>
<p><a class=p_ident id="p_6dW5nJMDK8" href="#p_6dW5nJMDK8"></a>When drawing the latter two, it is useful to know that <code>Math.cos</code> and
<code>Math.sin</code> can be used to find coordinates on a circle around (0,0)
with radius 1. They interpret their argument as the position on this
circle, with zero denoting the point on the far right of the circle,
going clockwise until 2π (about 6.28) has taken us around the whole
circle. <code>Math.cos</code> tells you the x coordinate of the point that
corresponds to the given angle, <code>Math.sin</code> yields the y coordinate.
Positions (angles) higher than 2π or below 0 are valid—the rotation
repeats, so that <em>X</em>+2π refers to the same angle as <em>X</em>.</p>
<div class="image">
  <img src="img/cos_sin.svg" alt="Using cosine and sine to compute coordinates">
</div>
<p><a class=p_ident id="p_CNU5YV9I/u" href="#p_CNU5YV9I/u"></a>To go from a circle with radius 1 at point <em>0,0</em> to an arbitrary
circle, you must multiply the coordinates these functions give you by
the circle&#8217;s radius, and then add the coordinates of the circle&#8217;s
center to them.</p>
<p><a class=p_ident id="p_8n4Hu9tdGs" href="#p_8n4Hu9tdGs"></a>I recommend creating a function for each shape, and passing the
position, and optionally other things, such as the size or the number
of points, as parameters. The alternative, which is to “hard-code”
numbers all over your code, tends to make the code hard to read and
modify.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_GLmm6biuOa" href="#c_GLmm6biuOa"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"600"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"200"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);

  <span class="cm-comment">// Your code here.</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<div class=solution><div class=solution-text>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
The parallelogram is easy to draw using a path. Pick suitable
   center coordinates, and add each of the four corners around that.
</p>
</li>
<li>
<p>
The diamond can be drawn the easy way, with a path, or the
   interesting way, with a <code>rotate</code> transformation. To use rotation,
   you will have to apply a trick similar to what we did in the
   <code>flipHorizontally</code> function. Because you want to rotate around the
   center of your rectangle, and not around the point <em>0,0</em>, you must
   first <code>translate</code> to there, then rotate, and then translate back.
</p>
</li>
<li>
<p>
For the zigzag it becomes unpractical to write a new call to
   <code>lineTo</code> for each line segment. Instead you should use a loop. You
   can either have each iteration draw two line segments (right and
   then left again), or one, in which case you must use the evenness
   (<code>% 2</code>) of the loop index to determine whether to go left or right.
</p>
</li>
<li>
<p>
You&#8217;ll also need a loop for the spiral. If you draw a series of
   points, with each point moving further along a circle around the
   spiral&#8217;s center, you get a circle. If, during the loop, you vary
   the radius of the circle on which you are putting the current
   point, and go around more than once, the result is a spiral.
</p>
</li>
<li>
<p>
The star depicted is built out of <code>quadraticCurveTo</code> lines. You
   could also draw one with straight lines. Divide a circle into 8 (or
   however many points you want your star to have) pieces. Draw lines
   between these points, making them curve towards the center of the
   star (with <code>quadraticCurveTo</code>, you can use the center as control
   point).
</p>
</li>
</ol></div>
</div></div>
<h3 id="_the_pie_chart">The pie chart</h3>
<p><a class=p_ident id="p_5/ovyOQpmP" href="#p_5/ovyOQpmP"></a>Earlier in the chapter, we saw an example program that drew a simple
pie chart. Modify this program so that the name of each category is
shown next to the slice that represents it. Try to find a way to
automatically position this text that looks pleasing, and would work
for other data sets as well. You may assume that categories are no
smaller than 5% (i.e. there won&#8217;t be a bunch of tiny ones next to each
other).</p>
<p><a class=p_ident id="p_nTwqKbJWIc" href="#p_nTwqKbJWIc"></a>You might again need <code>Math.sin</code> and <code>Math.cos</code>, as described in the
previous exercise.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_Cj3tSwDBCJ" href="#c_Cj3tSwDBCJ"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"600"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"300"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">total</span> <span class="cm-operator">=</span> <span class="cm-variable">results</span>.<span class="cm-property">reduce</span>(<span class="cm-keyword">function</span>(<span class="cm-def">sum</span>, <span class="cm-def">choice</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">sum</span> <span class="cm-operator">+</span> <span class="cm-variable-2">choice</span>.<span class="cm-property">count</span>;
  }, <span class="cm-number">0</span>);

  <span class="cm-keyword">var</span> <span class="cm-variable">currentAngle</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-keyword">var</span> <span class="cm-variable">centerX</span> <span class="cm-operator">=</span> <span class="cm-number">300</span>, <span class="cm-variable">centerY</span> <span class="cm-operator">=</span> <span class="cm-number">150</span>;
  <span class="cm-comment">// Add code to draw the slice labels in this loop.</span>
  <span class="cm-variable">results</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">result</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">sliceAngle</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">count</span> <span class="cm-operator">/</span> <span class="cm-variable">total</span>) <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
    <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-variable">centerX</span>, <span class="cm-variable">centerY</span>, <span class="cm-number">100</span>,
           <span class="cm-variable">currentAngle</span>, <span class="cm-variable">currentAngle</span> <span class="cm-operator">+</span> <span class="cm-variable-2">sliceAngle</span>);
    <span class="cm-variable">currentAngle</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">sliceAngle</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-variable">centerX</span>, <span class="cm-variable">centerY</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">result</span>.<span class="cm-property">color</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">fill</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_HdZ8krVlO9" href="#p_HdZ8krVlO9"></a>You will need to call <code>drawText</code>, and set the context&#8217;s <code>textAlign</code>
and <code>textBaseline</code> properties in such a way that the text ends up where
you want it.</p>
<p><a class=p_ident id="p_DSGWU1Z3OF" href="#p_DSGWU1Z3OF"></a>A sensible way to position the labels would be to put the text on the
line going from the center of the pie through the middle of the slice.
You don&#8217;t want to put the text directly against the side of the pie,
but rather move it outside of it a given amount of pixels.</p>
<p><a class=p_ident id="p_kM123YG/Z7" href="#p_kM123YG/Z7"></a>The angle of this line is <code>currentAngle + 0.5 * sliceAngle</code>. The code
below finds a position on this line, 120 pixels from the center:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_A0rK11DEAl" href="#c_A0rK11DEAl"></a><span class="cm-keyword">var</span> <span class="cm-variable">middleAngle</span> <span class="cm-operator">=</span> <span class="cm-variable">currentAngle</span> <span class="cm-operator">+</span> <span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">sliceAngle</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">textX</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">cos</span>(<span class="cm-variable">middleAngle</span>) <span class="cm-operator">*</span> <span class="cm-number">120</span> <span class="cm-operator">+</span> <span class="cm-variable">centerX</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">textY</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable">middleAngle</span>) <span class="cm-operator">*</span> <span class="cm-number">120</span> <span class="cm-operator">+</span> <span class="cm-variable">centerY</span>;</pre>
<p><a class=p_ident id="p_O8MP7v4Gfr" href="#p_O8MP7v4Gfr"></a>For <code>textBaseline</code>, the value <code>"middle"</code> is probably appropriate when
using this approach. What to use for <code>textAlign</code> depends on the side
of the circle we are on—on the left, it should be <code>"right"</code>, and on
the right, it should be <code>"left"</code>, so that the text is positioned away
from the pie.</p>
<p><a class=p_ident id="p_BmCLUHGaC3" href="#p_BmCLUHGaC3"></a>If you are not sure how to find out which side of the circle a given
angle is on, look back to the explanation of <code>Math.cos</code> in the
previous exercise. The cosine of an angle tells us which x coordinate
it corresponds to, which in turn tells us exactly which side of the
circle we are on.</p>
</div></div>
<h3 id="_a_bouncing_ball">A bouncing ball</h3>
<p><a class=p_ident id="p_QtPClJ4kuI" href="#p_QtPClJ4kuI"></a>Use the <code>requestAnimationFrame</code> technique that we saw in Chapter 14
and Chapter 15 to draw a box with a bouncing ball inside of it. The
ball moves at a constant speed, and bounces off the box&#8217;s sides when
it hits them.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_z6JlgvBVsO" href="#c_z6JlgvBVsO"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"400"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"400"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);

  <span class="cm-keyword">var</span> <span class="cm-variable">lastTime</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">function</span> <span class="cm-variable">frame</span>(<span class="cm-def">time</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable">lastTime</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>)
      <span class="cm-variable">updateAnimation</span>(<span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-number">100</span>, <span class="cm-variable-2">time</span> <span class="cm-operator">-</span> <span class="cm-variable">lastTime</span>) <span class="cm-operator">/</span> <span class="cm-number">1000</span>);
    <span class="cm-variable">lastTime</span> <span class="cm-operator">=</span> <span class="cm-variable-2">time</span>;
    <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">frame</span>);
  }
  <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">frame</span>);

  <span class="cm-keyword">function</span> <span class="cm-variable">updateAnimation</span>(<span class="cm-def">step</span>) {
    <span class="cm-comment">// Your code here.</span>
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_v5+QhLhJAT" href="#p_v5+QhLhJAT"></a>A box is easy to draw with <code>strokeRect</code>. Define a variable that holds
its size (or two variables, if your box&#8217;s width and height differ). To
create a round ball, start a path, call <code>arc(x, y, radius, 0, 7)</code>—an
arc going from zero to more than a whole circle—and fill it.</p>
<p><a class=p_ident id="p_wlBTN9ml9f" href="#p_wlBTN9ml9f"></a>To model the ball&#8217;s position and speed, you can use the <code>Vector</code> type
from Chapter 15 (which is available on this page). Give it a
starting speed, preferably one that is not purely vertical or
horizontal, and every frame, multiply that speed with the amount of
time that elapsed. When the ball gets too close to a vertical wall,
invert the x component in its speed. Likewise, invert the y component
when it hits a horizontal wall.</p>
<p><a class=p_ident id="p_1wITPL6e42" href="#p_1wITPL6e42"></a>After finding the ball&#8217;s new position and speed, use <code>clearRect</code> to
delete the scene, and redraw it using the new position.</p>
</div></div>
<h3 id="_precomputed_mirroring">Precomputed mirroring</h3>
<p><a class=p_ident id="p_onlMAFaFji" href="#p_onlMAFaFji"></a>One unfortunate thing about transformations is that they slow down
drawing of bitmaps. For vector graphics, the effect is less serious,
since there only a few points (for example the center of a circle)
need to be transformed, and then drawing continues as normal. For a
bitmap image, the position of each pixel has to be transformed, and
though it is possible that browsers will get more clever about this in
the future, this currently causes a measurable increase in the time it
takes to draw a bitmap.</p>
<p><a class=p_ident id="p_b50ouk4znE" href="#p_b50ouk4znE"></a>In a game like ours, where we are only drawing a single transformed
sprite, this is a non-issue. But imagine that we need to draw hundreds
of characters, or thousands of rotating particles from an explosion.</p>
<p><a class=p_ident id="p_WgNsgEoaNe" href="#p_WgNsgEoaNe"></a>Think of a way to allow us to draw an inverted character, without
drawing and loading additional image files, and without having to make
transformed <code>drawImage</code> calls every frame.</p>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_NmNTuxj7Ml" href="#p_NmNTuxj7Ml"></a>The key to the solution is the fact that we can use a canvas element
as a source image when using <code>drawImage</code>. It is possible to create an
extra <code>&lt;canvas&gt;</code> element, without adding it to the document, and draw
our inverted sprites to it, once. When drawing an actual frame, we
just copy the already inverted sprites to the main canvas.</p>
<p><a class=p_ident id="p_MbtRzmupcp" href="#p_MbtRzmupcp"></a>Some care would be required because images do not load instantly. We
only do the inverted drawing once, and if we do it before the image
loads, it won&#8217;t draw anything. A <code>"load"</code> handler on the image can be
used to draw the inverted images to the extra canvas. This canvas can
be used as a drawing source immediately (it&#8217;ll simply be blank until
we draw the character onto it).</p>
</div></div>
<nav>
  <a href="15_game.html" title="previous chapter">⬅</a>
  <a href="index.html" title="cover">⬆</a>
  <a href="17_http.html" title="next chapter">➡</a>
</nav>
</article>
